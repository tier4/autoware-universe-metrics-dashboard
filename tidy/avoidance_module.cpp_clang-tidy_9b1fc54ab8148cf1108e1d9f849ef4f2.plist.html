<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp": {"id": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "filePath": "planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "content": "// Copyright 2021 Tier IV, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef BEHAVIOR_PATH_PLANNER__SCENE_MODULE__AVOIDANCE__AVOIDANCE_MODULE_HPP_\n#define BEHAVIOR_PATH_PLANNER__SCENE_MODULE__AVOIDANCE__AVOIDANCE_MODULE_HPP_\n\n#include \"behavior_path_planner/path_shifter/path_shifter.hpp\"\n#include \"behavior_path_planner/scene_module/avoidance/avoidance_module_data.hpp\"\n#include \"behavior_path_planner/scene_module/scene_module_interface.hpp\"\n\n#include <rclcpp/rclcpp.hpp>\n\n#include <autoware_auto_perception_msgs/msg/predicted_objects.hpp>\n#include <autoware_auto_planning_msgs/msg/path.hpp>\n#include <autoware_auto_planning_msgs/msg/path_with_lane_id.hpp>\n#include <autoware_auto_vehicle_msgs/msg/turn_indicators_command.hpp>\n\n#include <memory>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace behavior_path_planner\n{\nclass AvoidanceModule : public SceneModuleInterface\n{\npublic:\n  AvoidanceModule(\n    const std::string & name, rclcpp::Node & node, const AvoidanceParameters & parameters);\n\n  bool isExecutionRequested() const override;\n  bool isExecutionReady() const override;\n  BT::NodeStatus updateState() override;\n  BehaviorModuleOutput plan() override;\n  PathWithLaneId planCandidate() const override;\n  BehaviorModuleOutput planWaitingApproval() override;\n  void onEntry() override;\n  void onExit() override;\n  void updateData() override;\n\n  void setParameters(const AvoidanceParameters & parameters);\n\nprivate:\n  AvoidanceParameters parameters_;\n\n  AvoidancePlanningData avoidance_data_;\n\n  PathShifter path_shifter_;\n\n  // data used in previous planning\n  ShiftedPath prev_output_;\n  ShiftedPath prev_linear_shift_path_;  // used for shift point check\n  PathWithLaneId prev_reference_;\n\n  // for raw_shift_point registration\n  AvoidPointArray registered_raw_shift_points_;\n  AvoidPointArray current_raw_shift_points_;\n  void registerRawShiftPoints(const AvoidPointArray & future_registered);\n  void updateRegisteredRawShiftPoints();\n\n  // -- for state management --\n  bool isAvoidancePlanRunning() const;\n\n  // -- for pre-processing --\n  void initVariables();\n  AvoidancePlanningData calcAvoidancePlanningData(DebugData & debug) const;\n  ObjectDataArray calcAvoidanceTargetObjects(\n    const lanelet::ConstLanelets & lanelets, const PathWithLaneId & reference_path,\n    DebugData & debug) const;\n\n  ObjectDataArray registered_objects_;\n  void updateRegisteredObject(const ObjectDataArray & objects);\n  void CompensateDetectionLost(ObjectDataArray & objects) const;\n\n  // -- for shift point generation --\n  AvoidPointArray calcShiftPoints(\n    AvoidPointArray & current_raw_shift_points, DebugData & debug) const;\n\n  // shift point generation: generator\n  AvoidPointArray calcRawShiftPointsFromObjects(const ObjectDataArray & objects) const;\n  double getRightShiftBound() const;\n  double getLeftShiftBound() const;\n\n  // shift point generation: combiner\n  AvoidPointArray combineRawShiftPointsWithUniqueCheck(\n    const AvoidPointArray & base_points, const AvoidPointArray & added_points) const;\n\n  // shift point generation: merger\n  AvoidPointArray mergeShiftPoints(\n    const AvoidPointArray & raw_shift_points, DebugData & debug) const;\n  void generateTotalShiftLine(\n    const AvoidPointArray & avoid_points, ShiftLineData & shift_line_data) const;\n  AvoidPointArray extractShiftPointsFromLine(ShiftLineData & shift_line_data) const;\n  std::vector<size_t> calcParentIds(\n    const AvoidPointArray & parent_candidates, const AvoidPoint & child) const;\n\n  // shift point generation: trimmers\n  AvoidPointArray trimShiftPoint(const AvoidPointArray & shift_points, DebugData & debug) const;\n  void quantizeShiftPoint(AvoidPointArray & shift_points, const double interval) const;\n  void trimSmallShiftPoint(AvoidPointArray & shift_points, const double shift_diff_thres) const;\n  void trimSimilarGradShiftPoint(AvoidPointArray & shift_points, const double threshold) const;\n  void trimMomentaryReturn(AvoidPointArray & shift_points) const;\n  void trimTooSharpShift(AvoidPointArray & shift_points) const;\n  void trimSharpReturn(AvoidPointArray & shift_points) const;\n\n  // shift point generation: return-shift generator\n  void addReturnShiftPointFromEgo(\n    AvoidPointArray & sp_candidates, AvoidPointArray & current_raw_shift_points) const;\n\n  // -- for shift point operations --\n  void alignShiftPointsOrder(\n    AvoidPointArray & shift_points, const bool recalc_start_length = true) const;\n  AvoidPointArray fillAdditionalInfo(const AvoidPointArray & shift_points) const;\n  AvoidPoint fillAdditionalInfo(const AvoidPoint & shift_point) const;\n  void fillAdditionalInfoFromPoint(AvoidPointArray & shift_points) const;\n  void fillAdditionalInfoFromLongitudinal(AvoidPointArray & shift_points) const;\n\n  // -- for new shift point approval --\n  boost::optional<AvoidPointArray> findNewShiftPoint(\n    const AvoidPointArray & shift_points, const PathShifter & shifter) const;\n  void addShiftPointIfApproved(const AvoidPointArray & point);\n  void addNewShiftPoints(PathShifter & path_shifter, const AvoidPointArray & shift_points) const;\n\n  // -- path generation --\n  ShiftedPath generateAvoidancePath(PathShifter & shifter) const;\n  void generateExtendedDrivableArea(ShiftedPath * shifted_path) const;\n\n  // -- velocity planning --\n  void modifyPathVelocityToPreventAccelerationOnAvoidance(ShiftedPath & shifted_path) const;\n\n  // clean up shifter\n  void postProcess(PathShifter & shifter) const;\n\n  // turn signal\n  TurnSignalInfo calcTurnSignalInfo(const ShiftedPath & path) const;\n\n  // intersection (old)\n  boost::optional<AvoidPoint> calcIntersectionShiftPoint(const AvoidancePlanningData & data) const;\n\n  bool isTargetObjectType(const PredictedObject & object) const;\n\n  // debug\n  mutable DebugData debug_data_;\n  void setDebugData(const PathShifter & shifter, const DebugData & debug);\n\n  // =====================================\n  // ========= helper functions ==========\n  // =====================================\n\n  PathWithLaneId calcCenterLinePath(\n    const std::shared_ptr<const PlannerData> & planner_data, const PoseStamped & pose) const;\n\n  void clipPathLength(PathWithLaneId & path) const;\n\n  // TODO(Horibe): think later.\n  // for unique ID\n  mutable uint64_t original_unique_id = 0;  // TODO(Horibe) remove mutable\n  uint64_t getOriginalShiftPointUniqueId() const { return original_unique_id++; }\n\n  double getNominalAvoidanceDistance(const double shift_length) const;\n  double getNominalPrepareDistance() const;\n  double getNominalAvoidanceEgoSpeed() const;\n\n  double getSharpAvoidanceDistance(const double shift_length) const;\n  double getSharpAvoidanceEgoSpeed() const;\n\n  double getEgoSpeed() const;\n  Point getEgoPosition() const;\n  PoseStamped getEgoPose() const;\n  PoseStamped getUnshiftedEgoPose(const ShiftedPath & prev_path) const;\n  double getCurrentBaseShift() const { return path_shifter_.getBaseOffset(); }\n  double getCurrentShift() const;\n  double getCurrentLinearShift() const;\n};\n\n}  // namespace behavior_path_planner\n\n#endif  // BEHAVIOR_PATH_PLANNER__SCENE_MODULE__AVOIDANCE__AVOIDANCE_MODULE_HPP_\n"}, "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp": {"id": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "filePath": "planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "content": "// Copyright 2021 Tier IV, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"behavior_path_planner/scene_module/avoidance/avoidance_module.hpp\"\n\n#include \"behavior_path_planner/path_utilities.hpp\"\n#include \"behavior_path_planner/scene_module/avoidance/avoidance_utils.hpp\"\n#include \"behavior_path_planner/scene_module/avoidance/debug.hpp\"\n#include \"behavior_path_planner/utilities.hpp\"\n\n#include <lanelet2_extension/utility/message_conversion.hpp>\n#include <lanelet2_extension/utility/utilities.hpp>\n#include <opencv2/opencv.hpp>\n#include <tier4_autoware_utils/tier4_autoware_utils.hpp>\n\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n// set as macro so that calling function name will be printed.\n// debug print is heavy. turn on only when debugging.\n#define DEBUG_PRINT(...) \\\n  RCLCPP_DEBUG_EXPRESSION(getLogger(), parameters_.print_debug_info, __VA_ARGS__)\n#define printShiftPoints(p, msg) DEBUG_PRINT(\"[%s] %s\", msg, toStrInfo(p).c_str())\n\nnamespace behavior_path_planner\n{\nusing tier4_autoware_utils::calcDistance2d;\nusing tier4_autoware_utils::calcLateralDeviation;\nusing tier4_autoware_utils::calcSignedArcLength;\nusing tier4_autoware_utils::createPoint;\nusing tier4_autoware_utils::findNearestIndex;\n\nAvoidanceModule::AvoidanceModule(\n  const std::string & name, rclcpp::Node & node, const AvoidanceParameters & parameters)\n: SceneModuleInterface{name, node}, parameters_{parameters}\n{\n  using std::placeholders::_1;\n\n  approval_handler_.waitApproval();\n}\n\nbool AvoidanceModule::isExecutionRequested() const\n{\n  DEBUG_PRINT(\"AVOIDANCE isExecutionRequested\");\n\n  if (current_state_ == BT::NodeStatus::RUNNING) {\n    return true;\n  }\n\n  DebugData debug;\n  const auto avoid_data = calcAvoidancePlanningData(debug);\n\n  const bool has_avoidance_target = !avoid_data.objects.empty();\n  return has_avoidance_target ? true : false;\n}\n\nbool AvoidanceModule::isExecutionReady() const\n{\n  DEBUG_PRINT(\"AVOIDANCE isExecutionReady\");\n\n  if (current_state_ == BT::NodeStatus::RUNNING) {\n    return true;\n  }\n\n  return true;\n}\n\nBT::NodeStatus AvoidanceModule::updateState()\n{\n  const auto is_plan_running = isAvoidancePlanRunning();\n\n  DebugData debug;\n  const auto avoid_data = calcAvoidancePlanningData(debug);\n  const bool has_avoidance_target = !avoid_data.objects.empty();\n\n  if (!is_plan_running && !has_avoidance_target) {\n    current_state_ = BT::NodeStatus::SUCCESS;\n  } else {\n    current_state_ = BT::NodeStatus::RUNNING;\n  }\n\n  DEBUG_PRINT(\n    \"is_plan_running = %d, has_avoidance_target = %d\", is_plan_running, has_avoidance_target);\n\n  return current_state_;\n}\n\nbool AvoidanceModule::isAvoidancePlanRunning() const\n{\n  const bool has_base_offset = std::abs(path_shifter_.getBaseOffset()) > 0.01;\n  const bool has_shift_point = (path_shifter_.getShiftPointsSize() > 0);\n  return has_base_offset || has_shift_point;\n}\n\nAvoidancePlanningData AvoidanceModule::calcAvoidancePlanningData(DebugData & debug) const\n{\n  AvoidancePlanningData data;\n\n  // reference pose\n  const auto reference_pose = getUnshiftedEgoPose(prev_output_);\n  data.reference_pose = reference_pose.pose;\n\n  // center line path (output of this function must have size > 1)\n  const auto center_path = calcCenterLinePath(planner_data_, reference_pose);\n  debug.center_line = center_path;\n  if (center_path.points.size() < 2) {\n    RCLCPP_WARN_THROTTLE(\n      getLogger(), *clock_, 5000, \"calcCenterLinePath() must return path which size > 1\");\n    return data;\n  }\n\n  // reference path\n  data.reference_path =\n    util::resamplePathWithSpline(center_path, parameters_.resample_interval_for_planning);\n  if (data.reference_path.points.size() < 2) {\n    // if the resampled path has only 1 point, use original path.\n    data.reference_path = center_path;\n  }\n  data.ego_closest_path_index =\n    findNearestIndex(data.reference_path.points, data.reference_pose.position);\n\n  // arclength from ego pose (used in many functions)\n  data.arclength_from_ego = util::calcPathArcLengthArray(\n    data.reference_path, 0, data.reference_path.points.size(),\n    calcSignedArcLength(data.reference_path.points, getEgoPosition(), 0));\n\n  // lanelet info\n  data.current_lanelets = calcLaneAroundPose(\n    planner_data_, reference_pose.pose, planner_data_->parameters.backward_path_length);\n\n  // target objects for avoidance\n  data.objects = calcAvoidanceTargetObjects(data.current_lanelets, data.reference_path, debug);\n\n  DEBUG_PRINT(\"target object size = %lu\", data.objects.size());\n\n  return data;\n}\n\nObjectDataArray AvoidanceModule::calcAvoidanceTargetObjects(\n  const lanelet::ConstLanelets & current_lanes, const PathWithLaneId & reference_path,\n  DebugData & debug) const\n{\n  using lanelet::geometry::distance2d;\n  using lanelet::utils::getId;\n  using lanelet::utils::to2D;\n\n  const auto & path_points = reference_path.points;\n  const auto & ego_pos = getEgoPosition();\n\n  // velocity filter: only for stopped vehicle\n  const auto objects_candidate = util::filterObjectsByVelocity(\n    *planner_data_->dynamic_object, parameters_.threshold_speed_object_is_stopped);\n\n  // detection area filter\n  // when expanding lanelets, right_offset must be minus.\n  // This is because y axis is positive on the left.\n  const auto expanded_lanelets = lanelet::utils::getExpandedLanelets(\n    current_lanes, parameters_.detection_area_left_expand_dist,\n    parameters_.detection_area_right_expand_dist * (-1.0));\n  const auto lane_filtered_objects_index =\n    util::filterObjectsByLanelets(objects_candidate, expanded_lanelets);\n\n  DEBUG_PRINT(\"dynamic_objects size = %lu\", planner_data_->dynamic_object->objects.size());\n  DEBUG_PRINT(\"object_candidate size = %lu\", objects_candidate.objects.size());\n  DEBUG_PRINT(\"lane_filtered_objects size = %lu\", lane_filtered_objects_index.size());\n\n  // for goal\n  const auto & rh = planner_data_->route_handler;\n  const auto dist_to_goal =\n    rh->isInGoalRouteSection(expanded_lanelets.back())\n      ? calcSignedArcLength(path_points, ego_pos, rh->getGoalPose().position)\n      : std::numeric_limits<double>::max();\n\n  lanelet::ConstLineStrings3d debug_linestring;\n  debug_linestring.clear();\n  // for filtered objects\n  ObjectDataArray target_objects;\n  for (const auto & i : lane_filtered_objects_index) {\n    const auto & object = objects_candidate.objects.at(i);\n    const auto & object_pos = object.kinematics.initial_pose_with_covariance.pose.position;\n\n    if (!isTargetObjectType(object)) {\n      DEBUG_PRINT(\"Ignore object: (isTargetObjectType is false)\");\n      continue;\n    }\n\n    ObjectData object_data;\n    object_data.object = object;\n\n    // calc longitudinal distance from ego to closest target object footprint point.\n    object_data.longitudinal = calcDistanceToClosestFootprintPoint(reference_path, object, ego_pos);\n\n    // object is behind ego or too far.\n    if (object_data.longitudinal < -parameters_.object_check_backward_distance) {\n      DEBUG_PRINT(\"Ignore object: (object < -backward_distance threshold)\");\n      continue;\n    }\n    if (object_data.longitudinal > parameters_.object_check_forward_distance) {\n      DEBUG_PRINT(\"Ignore object: (object > forward_distance threshold)\");\n      continue;\n    }\n\n    // Target object is behind the path goal -> ignore.\n    if (object_data.longitudinal > dist_to_goal) {\n      DEBUG_PRINT(\"Ignore object: (object is behind the path goal)\");\n      continue;\n    }\n\n    // Calc lateral deviation from path to target object.\n    const auto object_closest_index = findNearestIndex(path_points, object_pos);\n    const auto object_closest_pose = path_points.at(object_closest_index).point.pose;\n    object_data.lateral = calcLateralDeviation(object_closest_pose, object_pos);\n\n    // Find the footprint point closest to the path, set to object_data.overhang_distance.\n    object_data.overhang_dist =\n      calcOverhangDistance(object_data, object_closest_pose, object_data.overhang_pose.position);\n\n    lanelet::ConstLanelet overhang_lanelet;\n    if (!rh->getClosestLaneletWithinRoute(object_closest_pose, &overhang_lanelet)) {\n      continue;\n    }\n\n    if (overhang_lanelet.id()) {\n      object_data.overhang_lanelet = overhang_lanelet;\n      lanelet::BasicPoint3d overhang_basic_pose(\n        object_data.overhang_pose.position.x, object_data.overhang_pose.position.y,\n        object_data.overhang_pose.position.z);\n      const bool get_left =\n        isOnRight(object_data) && parameters_.enable_avoidance_over_same_direction;\n      const bool get_right =\n        !isOnRight(object_data) && parameters_.enable_avoidance_over_same_direction;\n\n      const auto target_lines = rh->getFurthestLinestring(\n        overhang_lanelet, get_right, get_left,\n        parameters_.enable_avoidance_over_opposite_direction);\n\n      if (isOnRight(object_data)) {\n        object_data.to_road_shoulder_distance =\n          distance2d(to2D(overhang_basic_pose), to2D(target_lines.back().basicLineString()));\n        debug_linestring.push_back(target_lines.back());\n      } else {\n        object_data.to_road_shoulder_distance =\n          distance2d(to2D(overhang_basic_pose), to2D(target_lines.front().basicLineString()));\n        debug_linestring.push_back(target_lines.front());\n      }\n    }\n\n    DEBUG_PRINT(\n      \"set object_data: longitudinal = %f, lateral = %f, largest_overhang = %f,\"\n      \"to_road_shoulder_distance = %f\",\n      object_data.longitudinal, object_data.lateral, object_data.overhang_dist,\n      object_data.to_road_shoulder_distance);\n\n    // Object is on center line -> ignore.\n    if (std::abs(object_data.lateral) < parameters_.threshold_distance_object_is_on_center) {\n      DEBUG_PRINT(\"Ignore object: (object is on center line)\");\n      continue;\n    }\n\n    // set data\n    target_objects.push_back(object_data);\n  }\n\n  // debug\n  {\n    debug.farthest_linestring_from_overhang =\n      std::make_shared<lanelet::ConstLineStrings3d>(debug_linestring);\n    debug.current_lanelets = std::make_shared<lanelet::ConstLanelets>(current_lanes);\n    debug.expanded_lanelets = std::make_shared<lanelet::ConstLanelets>(expanded_lanelets);\n  }\n\n  return target_objects;\n}\n\n/**\n * updateRegisteredRawShiftPoints\n *\n *  - update path index of the registered objects\n *  - remove old objects whose end point is behind ego pose.\n */\nvoid AvoidanceModule::updateRegisteredRawShiftPoints()\n{\n  fillAdditionalInfoFromPoint(registered_raw_shift_points_);\n\n  AvoidPointArray avoid_points;\n  const int margin = 0;\n  const auto deadline = static_cast<size_t>(\n    std::max(static_cast<int>(avoidance_data_.ego_closest_path_index) - margin, 0));\n\n  for (const auto & ap : registered_raw_shift_points_) {\n    if (ap.end_idx > deadline) {\n      avoid_points.push_back(ap);\n    }\n  }\n\n  DEBUG_PRINT(\n    \"ego_closest_path_index = %lu, registered_raw_shift_points_ size: %lu -> %lu\",\n    avoidance_data_.ego_closest_path_index, registered_raw_shift_points_.size(),\n    avoid_points.size());\n\n  printShiftPoints(registered_raw_shift_points_, \"registered_raw_shift_points_ (before)\");\n  printShiftPoints(avoid_points, \"registered_raw_shift_points_ (after)\");\n\n  registered_raw_shift_points_ = avoid_points;\n  debug_data_.registered_raw_shift = registered_raw_shift_points_;\n}\n\nAvoidPointArray AvoidanceModule::calcShiftPoints(\n  AvoidPointArray & current_raw_shift_points, DebugData & debug) const\n{\n  /**\n   * Generate raw_shift_points (shift length, avoidance start point, end point, return point, etc)\n   * for each object. These raw shift points are merged below to compute appropriate shift points.\n   */\n  current_raw_shift_points = calcRawShiftPointsFromObjects(avoidance_data_.objects);\n  debug.current_raw_shift = current_raw_shift_points;\n\n  /**\n   * Use all registered points. For the current points, if the similar one of the current\n   * points are already registered, will not use it.\n   * TODO(Horibe): enrich this logic to be able to consider the removal of the registered\n   *               shift, because it cannot handle the case like \"we don't have to avoid\n   *               the object anymore\".\n   */\n  auto total_raw_shift_points =\n    combineRawShiftPointsWithUniqueCheck(registered_raw_shift_points_, current_raw_shift_points);\n\n  printShiftPoints(current_raw_shift_points, \"current_raw_shift_points\");\n  printShiftPoints(registered_raw_shift_points_, \"registered_raw_shift_points\");\n  printShiftPoints(total_raw_shift_points, \"total_raw_shift_points\");\n\n  /*\n   * Add return-to-center shift point from the last shift point, if needed.\n   * If there is no shift points, set return-to center shift from ego.\n   */\n  // TODO(Horibe) Here, the return point is calculated considering the prepare distance,\n  // but there is an issue that sometimes this prepare distance is erased by the trimSimilarGrad,\n  // and it suddenly tries to return from ego. Then steer rotates aggressively.\n  // It is temporally solved by changing the threshold of trimSimilarGrad, but it needs to be\n  // fixed in a proper way.\n  // Maybe after merge, all shift points before the prepare distance can be deleted.\n  addReturnShiftPointFromEgo(total_raw_shift_points, current_raw_shift_points);\n  printShiftPoints(total_raw_shift_points, \"total_raw_shift_points_with_extra_return_shift\");\n\n  /**\n   * On each path point, compute shift length with considering the raw shift points.\n   * Then create a merged shift points by finding the change point of the gradient of shifting.\n   *  - take maximum shift length if there is duplicate shift point\n   *  - take sum if there are shifts for opposite direction (right and left)\n   *  - shift length is interpolated linearly.\n   * Note: Because this function just foolishly extracts points, it includes\n   *       insignificant small (useless) shift points, which should be removed in post-process.\n   */\n  auto merged_shift_points = mergeShiftPoints(total_raw_shift_points, debug);\n  debug.merged = merged_shift_points;\n\n  /*\n   * Remove unnecessary shift points\n   *  - Quantize the shift length to reduce the shift point noise\n   *  - Change the shift length to the previous one if the deviation is small.\n   *  - Combine shift points that have almost same gradient\n   *  - Remove unnecessary return shift (back to the center line).\n   */\n  auto shift_points = trimShiftPoint(merged_shift_points, debug);\n  DEBUG_PRINT(\"final shift point size = %lu\", shift_points.size());\n\n  return shift_points;\n}\n\nvoid AvoidanceModule::registerRawShiftPoints(const AvoidPointArray & future)\n{\n  if (future.empty()) {\n    RCLCPP_ERROR(getLogger(), \"future is empty! return.\");\n    return;\n  }\n\n  const auto old_size = registered_raw_shift_points_.size();\n\n  const auto future_with_info = fillAdditionalInfo(future);\n  printShiftPoints(future_with_info, \"future_with_info\");\n  printShiftPoints(registered_raw_shift_points_, \"registered_raw_shift_points_\");\n  printShiftPoints(current_raw_shift_points_, \"current_raw_shift_points_\");\n\n  const auto isAlreadyRegistered = [this](const auto id) {\n    const auto & r = registered_raw_shift_points_;\n    return std::any_of(r.begin(), r.end(), [id](const auto & r_sp) { return r_sp.id == id; });\n  };\n\n  const auto getAvoidPointByID = [this](const auto id) {\n    for (const auto & sp : current_raw_shift_points_) {\n      if (sp.id == id) {\n        return sp;\n      }\n    }\n    return AvoidPoint{};\n  };\n\n  for (const auto & ap : future_with_info) {\n    if (ap.parent_ids.empty()) {\n      RCLCPP_ERROR(getLogger(), \"avoid point for path_shifter must have parent_id.\");\n    }\n    for (const auto parent_id : ap.parent_ids) {\n      if (!isAlreadyRegistered(parent_id)) {\n        registered_raw_shift_points_.push_back(getAvoidPointByID(parent_id));\n      }\n    }\n  }\n\n  DEBUG_PRINT(\"registered object size: %lu -> %lu\", old_size, registered_raw_shift_points_.size());\n}\n\n/**\n * calcRawShiftPointsFromObjects\n *\n * Calculate the shift points (start/end point, shift length) from the object lateral\n * and longitudinal positions in the Frenet coordinate. The jerk limit is also considered here.\n */\nAvoidPointArray AvoidanceModule::calcRawShiftPointsFromObjects(\n  const ObjectDataArray & objects) const\n{\n  const auto prepare_distance = getNominalPrepareDistance();\n\n  // To be consistent with changes in the ego position, the current shift length is considered.\n  const auto current_ego_shift = getCurrentShift();\n  // // implement lane detection here.\n  const auto & lat_collision_safety_buffer = parameters_.lateral_collision_safety_buffer;\n  const auto & lat_collision_margin = parameters_.lateral_collision_margin;\n  const auto & vehicle_width = planner_data_->parameters.vehicle_width;\n  const auto & road_shoulder_safety_margin = parameters_.road_shoulder_safety_margin;\n  const auto max_allowable_lateral_distance =\n    lat_collision_safety_buffer + lat_collision_margin + vehicle_width;\n\n  const auto avoid_margin =\n    lat_collision_safety_buffer + lat_collision_margin + 0.5 * vehicle_width;\n\n  AvoidPointArray avoid_points;\n  for (auto & o : objects) {\n    const auto max_shift_length =\n      o.to_road_shoulder_distance - road_shoulder_safety_margin - 0.5 * vehicle_width;\n    const auto max_left_shift_limit = [&o, &max_allowable_lateral_distance, &max_shift_length,\n                                       this]() noexcept {\n      const auto left_shift_constraint = std::min(getLeftShiftBound(), max_shift_length);\n      return (o.to_road_shoulder_distance > max_allowable_lateral_distance) ? left_shift_constraint\n                                                                            : 0.0;\n    };\n\n    const auto max_right_shift_limit = [&o, &max_allowable_lateral_distance, &max_shift_length,\n                                        this]() noexcept {\n      const auto right_shift_constraint = std::max(getRightShiftBound(), -max_shift_length);\n      return (o.to_road_shoulder_distance > max_allowable_lateral_distance) ? right_shift_constraint\n                                                                            : 0.0;\n    };\n\n    const auto shift_length = isOnRight(o)\n                                ? std::min(o.overhang_dist + avoid_margin, max_left_shift_limit())\n                                : std::max(o.overhang_dist - avoid_margin, max_right_shift_limit());\n    const auto avoiding_shift = shift_length - current_ego_shift;\n    const auto return_shift = shift_length;\n\n    // use absolute dist for return-to-center, relative dist from current for avoiding.\n    const auto nominal_avoid_distance = getNominalAvoidanceDistance(avoiding_shift);\n    const auto nominal_return_distance = getNominalAvoidanceDistance(return_shift);\n\n    /**\n     * Is there enough distance from ego to object for avoidance?\n     *   - Yes -> use the nominal distance.\n     *   - No -> check if it is possible to avoid within maximum jerk limit.\n     *     - Yes -> use the stronger jerk.\n     *     - No -> ignore this object. Expected behavior is that the vehicle will stop in front\n     *             of the obstacle, then start avoidance.\n     */\n    const bool has_enough_distance = o.longitudinal > (prepare_distance + nominal_avoid_distance);\n    const auto remaining_distance = o.longitudinal - prepare_distance;\n    if (!has_enough_distance) {\n      if (remaining_distance <= 0.0) {\n        // TODO(Horibe) Even if there is no enough distance for avoidance shift, the\n        // return-to-center shift must be considered for each object if the current_shift\n        // is not zero.\n        DEBUG_PRINT(\"object is ignored since remaining_distance <= 0\");\n        continue;\n      }\n\n      // This is the case of exceeding the jerk limit. Use the sharp avoidance ego speed.\n      const auto required_jerk = path_shifter_.calcJerkFromLatLonDistance(\n        avoiding_shift, remaining_distance, getSharpAvoidanceEgoSpeed());\n      if (required_jerk > parameters_.max_lateral_jerk) {\n        DEBUG_PRINT(\n          \"object is ignored required_jerk is too large (req: %f, max: %f)\", required_jerk,\n          parameters_.max_lateral_jerk);\n        continue;\n      }\n    }\n    const auto avoiding_distance =\n      has_enough_distance ? nominal_avoid_distance : remaining_distance;\n\n    DEBUG_PRINT(\n      \"nominal_lateral_jerk = %f, getNominalAvoidanceEgoSpeed() = %f, prepare_distance = %f, \"\n      \"has_enough_distance = %d\",\n      parameters_.nominal_lateral_jerk, getNominalAvoidanceEgoSpeed(), prepare_distance,\n      has_enough_distance);\n\n    // TODO(Horibe): add margin with object length. __/\\__ -> __/\u00af\u00af\\__\n    AvoidPoint ap_avoid;\n    ap_avoid.length = shift_length;\n    ap_avoid.start_length = current_ego_shift;\n    ap_avoid.end_longitudinal = o.longitudinal;\n    ap_avoid.start_longitudinal = o.longitudinal - avoiding_distance;\n    ap_avoid.id = getOriginalShiftPointUniqueId();\n    ap_avoid.object = o;\n    avoid_points.push_back(ap_avoid);\n\n    // The end_margin also has the purpose of preventing the return path from NOT being\n    // triggered at the end point.\n    const auto end_margin = 1.0;\n    const auto return_remaining_distance =\n      std::max(avoidance_data_.arclength_from_ego.back() - o.longitudinal - end_margin, 0.0);\n\n    AvoidPoint ap_return;\n    ap_return.length = 0.0;\n    ap_return.start_length = shift_length;\n    ap_return.start_longitudinal = o.longitudinal;\n    ap_return.end_longitudinal =\n      o.longitudinal + std::min(nominal_return_distance, return_remaining_distance);\n    ap_return.id = getOriginalShiftPointUniqueId();\n    ap_return.object = o;\n    avoid_points.push_back(ap_return);\n\n    DEBUG_PRINT(\n      \"object is set: avoid_shift = %f, return_shift = %f, dist = (avoidStart: %3.3f, avoidEnd: \"\n      \"%3.3f, returnEnd: %3.3f), avoiding_dist = (nom:%f, res:%f), avoid_margin = %f, return_dist \"\n      \"= %f\",\n      avoiding_shift, return_shift, ap_avoid.start_longitudinal, ap_avoid.end_longitudinal,\n      ap_return.end_longitudinal, nominal_avoid_distance, avoiding_distance, avoid_margin,\n      nominal_return_distance);\n  }\n\n  fillAdditionalInfoFromLongitudinal(avoid_points);\n\n  return avoid_points;\n}\n\nAvoidPointArray AvoidanceModule::fillAdditionalInfo(const AvoidPointArray & shift_points) const\n{\n  if (shift_points.empty()) {\n    return shift_points;\n  }\n\n  auto out_points = shift_points;\n\n  const auto & path = avoidance_data_.reference_path;\n  const auto arclength = avoidance_data_.arclength_from_ego;\n\n  // calc longitudinal\n  for (auto & sp : out_points) {\n    sp.start_idx = findNearestIndex(path.points, sp.start.position);\n    sp.start_longitudinal = arclength.at(sp.start_idx);\n    sp.end_idx = findNearestIndex(path.points, sp.end.position);\n    sp.end_longitudinal = arclength.at(sp.end_idx);\n  }\n\n  // sort by longitudinal\n  std::sort(out_points.begin(), out_points.end(), [](auto a, auto b) {\n    return a.end_longitudinal < b.end_longitudinal;\n  });\n\n  // calc relative lateral length\n  out_points.front().start_length = getCurrentBaseShift();\n  for (size_t i = 1; i < shift_points.size(); ++i) {\n    out_points.at(i).start_length = shift_points.at(i - 1).length;\n  }\n\n  return out_points;\n}\nAvoidPoint AvoidanceModule::fillAdditionalInfo(const AvoidPoint & shift_point) const\n{\n  const auto ret = fillAdditionalInfo(AvoidPointArray{shift_point});\n  return ret.front();\n}\n\nvoid AvoidanceModule::fillAdditionalInfoFromPoint(AvoidPointArray & shift_points) const\n{\n  if (shift_points.empty()) {\n    return;\n  }\n\n  const auto & path = avoidance_data_.reference_path;\n  const auto arclength = util::calcPathArcLengthArray(path);\n  const auto dist_path_front_to_ego =\n    calcSignedArcLength(path.points, 0, avoidance_data_.ego_closest_path_index);\n\n  // calc longitudinal\n  for (auto & sp : shift_points) {\n    sp.start_idx = findNearestIndex(path.points, sp.start.position);\n    sp.start_longitudinal = arclength.at(sp.start_idx) - dist_path_front_to_ego;\n    sp.end_idx = findNearestIndex(path.points, sp.end.position);\n    sp.end_longitudinal = arclength.at(sp.end_idx) - dist_path_front_to_ego;\n  }\n}\n\nvoid AvoidanceModule::fillAdditionalInfoFromLongitudinal(AvoidPointArray & shift_points) const\n{\n  const auto & path = avoidance_data_.reference_path;\n  const auto arclength = util::calcPathArcLengthArray(path);\n  const auto path_front_to_ego =\n    calcSignedArcLength(path.points, 0, avoidance_data_.ego_closest_path_index);\n\n  for (auto & sp : shift_points) {\n    sp.start_idx = findPathIndexFromArclength(arclength, sp.start_longitudinal + path_front_to_ego);\n    sp.start = path.points.at(sp.start_idx).point.pose;\n    sp.end_idx = findPathIndexFromArclength(arclength, sp.end_longitudinal + path_front_to_ego);\n    sp.end = path.points.at(sp.end_idx).point.pose;\n  }\n}\n/*\n * combineRawShiftPointsWithUniqueCheck\n *\n * Combine points A into B. If shift_point of A which has same object_id and\n * similar shape is already in B, it will not be added into B.\n */\nAvoidPointArray AvoidanceModule::combineRawShiftPointsWithUniqueCheck(\n  const AvoidPointArray & base_points, const AvoidPointArray & added_points) const\n{\n  // TODO(Horibe) parametrize\n  const auto isSimilar = [](const AvoidPoint & a, const AvoidPoint & b) {\n    using tier4_autoware_utils::calcDistance2d;\n    if (calcDistance2d(a.start, b.start) > 1.0) {\n      return false;\n    }\n    if (calcDistance2d(a.end, b.end) > 1.0) {\n      return false;\n    }\n    if (std::abs(a.length - b.length) > 0.5) {\n      return false;\n    }\n    return true;\n  };\n  const auto hasSameObjectId = [](const auto & a, const auto & b) {\n    return a.object.object.object_id == b.object.object.object_id;\n  };\n\n  auto combined = base_points;  // initialized\n  for (const auto & o : added_points) {\n    bool skip = false;\n\n    for (const auto & b : base_points) {\n      if (hasSameObjectId(o, b) && isSimilar(o, b)) {\n        skip = true;\n        break;\n      }\n    }\n    if (!skip) {\n      combined.push_back(o);\n    }\n  }\n\n  return combined;\n}\n\nvoid AvoidanceModule::generateTotalShiftLine(\n  const AvoidPointArray & avoid_points, ShiftLineData & shift_line_data) const\n{\n  const auto & path = avoidance_data_.reference_path;\n  const auto & arclengths = avoidance_data_.arclength_from_ego;\n  const auto N = path.points.size();\n\n  auto & sl = shift_line_data;\n\n  sl.shift_line = std::vector<double>(N, 0.0);\n  sl.shift_line_grad = std::vector<double>(N, 0.0);\n\n  sl.pos_shift_line = std::vector<double>(N, 0.0);\n  sl.neg_shift_line = std::vector<double>(N, 0.0);\n\n  sl.pos_shift_line_grad = std::vector<double>(N, 0.0);\n  sl.neg_shift_line_grad = std::vector<double>(N, 0.0);\n\n  // debug\n  sl.shift_line_history = std::vector<std::vector<double>>(avoid_points.size(), sl.shift_line);\n\n  // take minmax for same directional shift length\n  for (size_t j = 0; j < avoid_points.size(); ++j) {\n    const auto & ap = avoid_points.at(j);\n    for (size_t i = 0; i < N; ++i) {\n      // calc current interpolated shift\n      const auto i_shift = lerpShiftLengthOnArc(arclengths.at(i), ap);\n\n      // update maximum shift for positive direction\n      if (i_shift > sl.pos_shift_line.at(i)) {\n        sl.pos_shift_line.at(i) = i_shift;\n        sl.pos_shift_line_grad.at(i) = ap.getGradient();\n      }\n\n      // update minumum shift for negative direction\n      if (i_shift < sl.neg_shift_line.at(i)) {\n        sl.neg_shift_line.at(i) = i_shift;\n        sl.neg_shift_line_grad.at(i) = ap.getGradient();\n      }\n\n      // store for debug print\n      sl.shift_line_history.at(j).at(i) = i_shift;\n    }\n  }\n\n  // Merge shift length of opposite directions.\n  for (size_t i = 0; i < N; ++i) {\n    sl.shift_line.at(i) = sl.pos_shift_line.at(i) + sl.neg_shift_line.at(i);\n    sl.shift_line_grad.at(i) = sl.pos_shift_line_grad.at(i) + sl.neg_shift_line_grad.at(i);\n  }\n\n  // overwrite shift with current_ego_shift until ego pose.\n  const auto current_shift = getCurrentLinearShift();\n  for (size_t i = 0; i <= avoidance_data_.ego_closest_path_index; ++i) {\n    sl.shift_line.at(i) = current_shift;\n    sl.shift_line_grad.at(i) = 0.0;\n  }\n\n  // If the shift point does not have an associated object,\n  // use previous value.\n  for (size_t i = 1; i < N; ++i) {\n    bool has_object = false;\n    for (const auto & ap : avoid_points) {\n      if (ap.start_idx < i && i < ap.end_idx) {\n        has_object = true;\n        break;\n      }\n    }\n    if (!has_object) {\n      sl.shift_line.at(i) = sl.shift_line.at(i - 1);\n    }\n  }\n  sl.shift_line_history.push_back(sl.shift_line);\n}\n\nAvoidPointArray AvoidanceModule::extractShiftPointsFromLine(ShiftLineData & shift_line_data) const\n{\n  const auto & path = avoidance_data_.reference_path;\n  const auto & arclengths = avoidance_data_.arclength_from_ego;\n  const auto N = path.points.size();\n\n  auto & sl = shift_line_data;\n\n  const auto getBwdGrad = [&](const size_t i) {\n    if (i == 0) {\n      return sl.shift_line_grad.at(i);\n    }\n    const double ds = arclengths.at(i) - arclengths.at(i - 1);\n    if (ds < 1.0e-5) {\n      return sl.shift_line_grad.at(i);\n    }  // use theoretical value when ds is too small.\n    return (sl.shift_line.at(i) - sl.shift_line.at(i - 1)) / ds;\n  };\n\n  const auto getFwdGrad = [&](const size_t i) {\n    if (i == arclengths.size() - 1) {\n      return sl.shift_line_grad.at(i);\n    }\n    const double ds = arclengths.at(i + 1) - arclengths.at(i);\n    if (ds < 1.0e-5) {\n      return sl.shift_line_grad.at(i);\n    }  // use theoretical value when ds is too small.\n    return (sl.shift_line.at(i + 1) - sl.shift_line.at(i)) / ds;\n  };\n\n  // calculate forward and backward gradient of the shift length.\n  // This will be used for grad-change-point check.\n  sl.forward_grad = std::vector<double>(N, 0.0);\n  sl.backward_grad = std::vector<double>(N, 0.0);\n  for (size_t i = 0; i < N - 1; ++i) {\n    sl.forward_grad.at(i) = getFwdGrad(i);\n    sl.backward_grad.at(i) = getBwdGrad(i);\n  }\n\n  AvoidPointArray merged_avoid_points;\n  AvoidPoint ap{};\n  bool found_first_start = false;\n  constexpr auto CREATE_SHIFT_GRAD_THR = 0.001;\n  constexpr auto IS_ALREADY_SHIFTING_THR = 0.001;\n  for (size_t i = avoidance_data_.ego_closest_path_index; i < N - 1; ++i) {\n    const auto & p = path.points.at(i).point.pose;\n    const auto shift = sl.shift_line.at(i);\n\n    // If the vehicle is already on the avoidance (checked by the first point has shift),\n    // set a start point at the first path point.\n    if (!found_first_start && std::abs(shift) > IS_ALREADY_SHIFTING_THR) {\n      setStartData(ap, 0.0, p, i, arclengths.at(i));  // start length is overwritten later.\n      found_first_start = true;\n      DEBUG_PRINT(\"shift (= %f) is not zero at i = %lu. set start shift here.\", shift, i);\n    }\n\n    // find the point where the gradient of the shift is changed\n    const bool set_shift_point_flag =\n      std::abs(sl.forward_grad.at(i) - sl.backward_grad.at(i)) > CREATE_SHIFT_GRAD_THR;\n\n    if (!set_shift_point_flag) {\n      continue;\n    }\n\n    if (!found_first_start) {\n      setStartData(ap, 0.0, p, i, arclengths.at(i));  // start length is overwritten later.\n      found_first_start = true;\n      DEBUG_PRINT(\"grad change detected. start at i = %lu\", i);\n    } else {\n      setEndData(ap, shift, p, i, arclengths.at(i));\n      ap.id = getOriginalShiftPointUniqueId();\n      merged_avoid_points.push_back(ap);\n      setStartData(ap, 0.0, p, i, arclengths.at(i));  // start length is overwritten later.\n      DEBUG_PRINT(\"end and start point found at i = %lu\", i);\n    }\n  }\n  return merged_avoid_points;\n}\n\nAvoidPointArray AvoidanceModule::mergeShiftPoints(\n  const AvoidPointArray & raw_shift_points, DebugData & debug) const\n{\n  // Generate shift line by merging raw_shift_points.\n  ShiftLineData shift_line_data;\n  generateTotalShiftLine(raw_shift_points, shift_line_data);\n\n  // Re-generate shift points by detecting gradient-change point of the shift line.\n  auto merged_shift_points = extractShiftPointsFromLine(shift_line_data);\n\n  // set parent id\n  for (auto & ap : merged_shift_points) {\n    ap.parent_ids = calcParentIds(raw_shift_points, ap);\n  }\n\n  // sort by distance from ego.\n  alignShiftPointsOrder(merged_shift_points);\n\n  // debug visualize\n  {\n    debug.pos_shift = shift_line_data.pos_shift_line;\n    debug.neg_shift = shift_line_data.neg_shift_line;\n    debug.total_shift = shift_line_data.shift_line;\n  }\n\n  // debug print\n  {\n    const auto & arc = avoidance_data_.arclength_from_ego;\n    const auto & closest = avoidance_data_.ego_closest_path_index;\n    const auto & sl = shift_line_data.shift_line;\n    const auto & sg = shift_line_data.shift_line_grad;\n    const auto & fg = shift_line_data.forward_grad;\n    const auto & bg = shift_line_data.backward_grad;\n    using std::setw;\n    std::stringstream ss;\n    ss << std::fixed << std::setprecision(3);\n    ss << \"\\n[idx, arc, shift (for each shift points, filtered | total), grad (ideal, bwd, fwd)]: \"\n          \"closest = \"\n       << closest << \", raw_shift_points size = \" << raw_shift_points.size() << std::endl;\n    for (size_t i = 0; i < arc.size(); ++i) {\n      ss << \"i = \" << i << \" | arc: \" << arc.at(i) << \" | shift: (\";\n      for (const auto & p : shift_line_data.shift_line_history) {\n        ss << setw(5) << p.at(i) << \", \";\n      }\n      ss << \"| total: \" << setw(5) << sl.at(i) << \") | grad: (\" << sg.at(i) << \", \" << fg.at(i)\n         << \", \" << bg.at(i) << \")\" << std::endl;\n    }\n    DEBUG_PRINT(\"%s\", ss.str().c_str());\n  }\n\n  printShiftPoints(merged_shift_points, \"merged_shift_points\");\n\n  return merged_shift_points;\n}\n\nstd::vector<size_t> AvoidanceModule::calcParentIds(\n  const AvoidPointArray & parent_candidates, const AvoidPoint & child) const\n{\n  // Get the ID of the original AP whose transition area overlaps with the given AP,\n  // and set it to the parent id.\n  std::set<uint64_t> ids;\n  for (const auto & ap : parent_candidates) {\n    const auto p_s = ap.start_longitudinal;\n    const auto p_e = ap.end_longitudinal;\n    const auto has_overlap = !(p_e < child.start_longitudinal || child.end_longitudinal < p_s);\n\n    if (!has_overlap) {\n      continue;\n    }\n\n    // Id the shift is overlapped, insert the shift point. Additionally, the shift which refers\n    // to the same object id (created by the same object) will be set.\n    //\n    // Why? : think that there are two shifts, avoiding and .\n    // If you register only the avoiding shift, the return-to-center shift will not be generated\n    // when you get too close to or over the obstacle. The return-shift can be handled with\n    // addReturnShift(), but it maybe reasonable to register the return-to-center shift for the\n    // object at the same time as registering the avoidance shift to remove the complexity of the\n    // addReturnShift().\n    for (const auto & ap_local : parent_candidates) {\n      if (ap_local.object.object.object_id == ap.object.object.object_id) {\n        ids.insert(ap_local.id);\n      }\n    }\n  }\n  return std::vector<size_t>(ids.begin(), ids.end());\n}\n\n/*\n * Remove unnecessary avoid points\n * - Combine avoid points that have almost same gradient\n * - Quantize the shift length to reduce the shift point noise\n * - Change the shift length to the previous one if the deviation is small.\n * - Remove unnecessary return shift (back to the center line).\n */\nAvoidPointArray AvoidanceModule::trimShiftPoint(\n  const AvoidPointArray & shift_points, DebugData & debug) const\n{\n  if (shift_points.empty()) {\n    return shift_points;\n  }\n\n  AvoidPointArray sp_array_trimmed = shift_points;\n\n  // sort shift points from front to back.\n  alignShiftPointsOrder(sp_array_trimmed);\n\n  // - Combine avoid points that have almost same gradient.\n  // this is to remove the noise.\n  {\n    const auto CHANGE_SHIFT_THRESHOLD_FOR_NOISE = 0.1;\n    trimSimilarGradShiftPoint(sp_array_trimmed, CHANGE_SHIFT_THRESHOLD_FOR_NOISE);\n    debug.trim_similar_grad_shift = sp_array_trimmed;\n    printShiftPoints(sp_array_trimmed, \"after trim_similar_grad_shift\");\n  }\n\n  // - Quantize the shift length to reduce the shift point noise\n  // This is to remove the noise coming from detection accuracy, interpolation, resampling, etc.\n  {\n    constexpr double QUANTIZATION_DISTANCE = 0.2;\n    quantizeShiftPoint(sp_array_trimmed, QUANTIZATION_DISTANCE);\n    printShiftPoints(sp_array_trimmed, \"after sp_array_trimmed\");\n    debug.quantized = sp_array_trimmed;\n  }\n\n  // - Change the shift length to the previous one if the deviation is small.\n  {\n    // constexpr double SHIFT_DIFF_THRES = 0.5;\n    // trimSmallShiftPoint(sp_array_trimmed, SHIFT_DIFF_THRES);\n    debug.trim_small_shift = sp_array_trimmed;\n    printShiftPoints(sp_array_trimmed, \"after trim_small_shift\");\n  }\n\n  // - Combine avoid points that have almost same gradient (again)\n  {\n    const auto CHANGE_SHIFT_THRESHOLD = 0.2;\n    trimSimilarGradShiftPoint(sp_array_trimmed, CHANGE_SHIFT_THRESHOLD);\n    debug.trim_similar_grad_shift_second = sp_array_trimmed;\n    printShiftPoints(sp_array_trimmed, \"after trim_similar_grad_shift_second\");\n  }\n\n  // - trimTooSharpShift\n  // Check if it is not too sharp for the return-to-center shift point.\n  // If the shift is sharp, it is combined with the next shift point until it gets non-sharp.\n  {\n    trimSharpReturn(sp_array_trimmed);\n    debug.trim_too_sharp_shift = sp_array_trimmed;\n    printShiftPoints(sp_array_trimmed, \"after trimSharpReturn\");\n  }\n\n  return sp_array_trimmed;\n}\n\nvoid AvoidanceModule::alignShiftPointsOrder(\n  AvoidPointArray & shift_points, const bool recalc_start_length) const\n{\n  if (shift_points.empty()) {\n    return;\n  }\n\n  // sort shift points from front to back.\n  std::sort(shift_points.begin(), shift_points.end(), [](auto a, auto b) {\n    return a.end_longitudinal < b.end_longitudinal;\n  });\n\n  // calc relative length\n  // NOTE: the input shift point must not have conflict range. Otherwise relative\n  // length value will be broken.\n  if (recalc_start_length) {\n    shift_points.front().start_length = getCurrentLinearShift();\n    for (size_t i = 1; i < shift_points.size(); ++i) {\n      shift_points.at(i).start_length = shift_points.at(i - 1).length;\n    }\n  }\n}\n\nvoid AvoidanceModule::quantizeShiftPoint(\n  AvoidPointArray & shift_points, const double interval) const\n{\n  if (interval < 1.0e-5) {\n    return;  // no need to process\n  }\n\n  for (auto & sp : shift_points) {\n    sp.length = std::round(sp.length / interval) * interval;\n  }\n\n  alignShiftPointsOrder(shift_points);\n}\n\nvoid AvoidanceModule::trimSmallShiftPoint(\n  AvoidPointArray & shift_points, const double shift_diff_thres) const\n{\n  AvoidPointArray shift_points_orig = shift_points;\n  shift_points.clear();\n\n  shift_points.push_back(shift_points_orig.front());  // Take the first one anyway (think later)\n\n  for (size_t i = 1; i < shift_points_orig.size(); ++i) {\n    auto sp_now = shift_points_orig.at(i);\n    const auto sp_prev = shift_points.back();\n    const auto shift_diff = sp_now.length - sp_prev.length;\n\n    auto sp_modified = sp_now;\n\n    // remove the shift point if the length is almost same as the previous one.\n    if (std::abs(shift_diff) < shift_diff_thres) {\n      sp_modified.length = sp_prev.length;\n      sp_modified.start_length = sp_prev.length;\n      DEBUG_PRINT(\n        \"i = %lu, relative shift = %f is small. set with relative shift = 0.\", i, shift_diff);\n    } else {\n      DEBUG_PRINT(\"i = %lu, shift = %f is large. take this one normally.\", i, shift_diff);\n    }\n\n    shift_points.push_back(sp_modified);\n  }\n\n  alignShiftPointsOrder(shift_points);\n\n  DEBUG_PRINT(\"size %lu -> %lu\", shift_points_orig.size(), shift_points.size());\n}\n\nvoid AvoidanceModule::trimSimilarGradShiftPoint(\n  AvoidPointArray & avoid_points, const double change_shift_dist_threshold) const\n{\n  AvoidPointArray avoid_points_orig = avoid_points;\n  avoid_points.clear();\n\n  avoid_points.push_back(avoid_points_orig.front());  // Take the first one anyway (think later)\n\n  // Save the points being merged. When merging consecutively, also check previously merged points.\n  AvoidPointArray being_merged_points;\n\n  for (size_t i = 1; i < avoid_points_orig.size(); ++i) {\n    const auto ap_now = avoid_points_orig.at(i);\n    const auto ap_prev = avoid_points.back();\n\n    being_merged_points.push_back(ap_prev);  // This point is about to be merged.\n\n    auto combined_ap = ap_prev;\n    setEndData(combined_ap, ap_now.length, ap_now.end, ap_now.end_idx, ap_now.end_longitudinal);\n    combined_ap.parent_ids = concatParentIds(combined_ap.parent_ids, ap_prev.parent_ids);\n\n    const auto has_large_length_change = [&]() {\n      for (const auto & original : being_merged_points) {\n        const auto longitudinal = original.end_longitudinal - combined_ap.start_longitudinal;\n        const auto new_length = combined_ap.getGradient() * longitudinal + combined_ap.start_length;\n        const bool has_large_change =\n          std::abs(new_length - original.length) > change_shift_dist_threshold;\n\n        DEBUG_PRINT(\n          \"original.length: %f, original.end_longitudinal: %f, combined_ap.start_longitudinal: \"\n          \"%f, combined_ap.Gradient: %f, new_length: %f, has_large_change: %d\",\n          original.length, original.end_longitudinal, combined_ap.start_longitudinal,\n          combined_ap.getGradient(), new_length, has_large_change);\n\n        if (std::abs(new_length - original.length) > change_shift_dist_threshold) {\n          return true;\n        }\n      }\n      return false;\n    }();\n\n    if (has_large_length_change) {\n      // If this point is merged with the previous points, it makes a large changes.\n      // Do not merge this.\n      avoid_points.push_back(ap_now);\n      being_merged_points.clear();\n      DEBUG_PRINT(\"use this point. has_large_length_change = %d\", has_large_length_change);\n    } else {\n      avoid_points.back() = combined_ap;  // Update the last points by merging the current point\n      being_merged_points.push_back(ap_prev);\n      DEBUG_PRINT(\"trim! has_large_length_change = %d\", has_large_length_change);\n    }\n  }\n\n  alignShiftPointsOrder(avoid_points);\n\n  DEBUG_PRINT(\"size %lu -> %lu\", avoid_points_orig.size(), avoid_points.size());\n}\n\n/**\n * Remove short \"return to center\" shift point. \u00af\u00af\\_/\u00af\u00af\u3000-> \u00af\u00af\u00af\u00af\u00af\u00af\n *\n * Is the shift point for \"return to center\"?\n *  - no : Do not trim anything.\n *  - yes: Is it short distance enough to be removed?\n *     - no : Do not trim anything.\n *     - yes: Remove the \"return\" shift point.\n *            Recalculate longitudinal distance and modify the shift point.\n */\nvoid AvoidanceModule::trimMomentaryReturn(AvoidPointArray & shift_points) const\n{\n  const auto isZero = [](double v) { return std::abs(v) < 1.0e-5; };\n\n  AvoidPointArray shift_points_orig = shift_points;\n  shift_points.clear();\n\n  const double DISTANCE_AFTER_RETURN_THR = 5.0 * getNominalAvoidanceEgoSpeed();\n\n  const auto & arclength = avoidance_data_.arclength_from_ego;\n\n  const auto check_reduce_shift = [](const double now_length, const double prev_length) {\n    const auto abs_shift_diff = std::abs(now_length) - std::abs(prev_length);\n    const auto has_same_sign = (now_length * prev_length >= 0.0);\n    const bool is_reduce_shift = (abs_shift_diff < 0.0 && has_same_sign);\n    return is_reduce_shift;\n  };\n\n  for (size_t i = 0; i < shift_points_orig.size(); ++i) {\n    const auto sp_now = shift_points_orig.at(i);\n    const auto sp_prev_length =\n      shift_points.empty() ? getCurrentLinearShift() : shift_points.back().length;\n    const auto abs_shift_diff = std::abs(sp_now.length) - std::abs(sp_prev_length);\n    const bool is_reduce_shift = check_reduce_shift(sp_now.length, sp_prev_length);\n\n    // Do nothing for non-reduce shift point\n    if (!is_reduce_shift) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\n        \"i = %lu, not reduce shift. take this one.\u3000abs_shift_diff = %f, sp_now.length = %f, \"\n        \"sp_prev_length = %f, sp_now.length * sp_prev_length = %f\",\n        i, abs_shift_diff, sp_now.length, sp_prev_length, sp_now.length * sp_prev_length);\n      continue;\n    }\n\n    // The last point is out of target of this function.\n    const bool is_last_sp = (i == shift_points_orig.size() - 1);\n    if (is_last_sp) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\"i = %lu, last shift. take this one.\", i);\n      continue;\n    }\n\n    // --- From here, the shift point is \"return to center\" or \"straight\". ---\n    // -----------------------------------------------------------------------\n\n    const auto sp_next = shift_points_orig.at(i + 1);\n\n    // there is no straight interval, combine them. \u00af\u00af\\/\u00af\u00af -> \u00af\u00af\u00af\u00af\u00af\u00af\n    if (!isZero(sp_next.getRelativeLength())) {\n      DEBUG_PRINT(\n        \"i = %lu, return-shift is detected, next shift_diff (%f) is nonzero. combine them. (skip \"\n        \"next shift).\",\n        i, sp_next.getRelativeLength());\n      auto sp_modified = sp_next;\n      setStartData(\n        sp_modified, sp_now.length, sp_now.start, sp_now.start_idx, sp_now.start_longitudinal);\n      sp_modified.parent_ids = concatParentIds(sp_modified.parent_ids, sp_now.parent_ids);\n      shift_points.push_back(sp_modified);\n      ++i;  // skip next shift point\n      continue;\n    }\n\n    // Find next shifting point, i.e.  \u00af\u00af\\____\"/\"\u00af\u00af\n    //                               now \u2191     \u2191 target\n    const auto next_avoid_idx = [&]() {\n      for (size_t j = i + 1; j < shift_points_orig.size(); ++j) {\n        if (!isZero(shift_points_orig.at(j).getRelativeLength())) {\n          return j;\n        }\n      }\n      return shift_points_orig.size();\n    }();\n\n    // The straight distance lasts until end. take this one.\n    // \u00af\u00af\\______\n    if (next_avoid_idx == shift_points_orig.size()) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\"i = %lu, back -> straight lasts until end. take this one.\", i);\n      continue;\n    }\n\n    const auto sp_next_avoid = shift_points_orig.at(next_avoid_idx);\n    const auto straight_distance = sp_next_avoid.start_longitudinal - sp_now.end_longitudinal;\n\n    // The straight distance after \"return to center\" is long enough. take this one.\n    // \u00af\u00af\\______/\u00af\u00af (enough long straight line!)\n    if (straight_distance > DISTANCE_AFTER_RETURN_THR) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\"i = %lu, back -> straight: distance is long. take this one\", i);\n      continue;\n    }\n\n    // From here, back to center and go straight, straight distance is too short.\n    // \u00af\u00af\\______/\u00af\u00af (short straight line!)\n\n    const auto relative_shift = sp_next_avoid.length - sp_now.length;\n    const auto avoid_distance = getNominalAvoidanceDistance(relative_shift);\n\n    // Calculate start point from end point and avoidance distance.\n    auto sp_next_modified = sp_next_avoid;\n    sp_next_modified.start_length = sp_prev_length;\n    sp_next_modified.start_longitudinal =\n      std::max(sp_next_avoid.end_longitudinal - avoid_distance, sp_now.start_longitudinal);\n    sp_next_modified.start_idx =\n      findPathIndexFromArclength(arclength, sp_next_modified.start_longitudinal);\n    sp_next_modified.start =\n      avoidance_data_.reference_path.points.at(sp_next_modified.start_idx).point.pose;\n    sp_next_modified.parent_ids = calcParentIds(current_raw_shift_points_, sp_next_modified);\n\n    // Straight shift point\n    if (sp_next_modified.start_idx > sp_now.start_idx) {  // the case where a straight route exists.\n      auto sp_now_modified = sp_now;\n      sp_now_modified.start_length = sp_prev_length;\n      setEndData(\n        sp_now_modified, sp_prev_length, sp_next_modified.start, sp_next_modified.start_idx,\n        sp_next_modified.start_longitudinal);\n      sp_now_modified.parent_ids = calcParentIds(current_raw_shift_points_, sp_now_modified);\n      shift_points.push_back(sp_now_modified);\n    }\n    shift_points.push_back(sp_next_modified);\n\n    DEBUG_PRINT(\n      \"i = %lu, find remove target!: next_avoid_idx = %lu, shift length = (now: %f, prev: %f, \"\n      \"next_avoid: %f, next_mod: %f).\",\n      i, next_avoid_idx, sp_now.length, sp_prev_length, sp_next_avoid.length,\n      sp_next_modified.length);\n\n    i = next_avoid_idx;  // skip shifting until next_avoid_idx.\n  }\n\n  alignShiftPointsOrder(shift_points);\n\n  DEBUG_PRINT(\n    \"trimMomentaryReturn: size %lu -> %lu\", shift_points_orig.size(), shift_points.size());\n}\n\nvoid AvoidanceModule::trimSharpReturn(AvoidPointArray & shift_points) const\n{\n  AvoidPointArray shift_points_orig = shift_points;\n  shift_points.clear();\n\n  const auto isZero = [](double v) { return std::abs(v) < 0.01; };\n\n  // check if the shift point is positive (avoiding) shift\n  const auto isPositive = [&](const auto & sp) {\n    constexpr auto POSITIVE_SHIFT_THR = 0.1;\n    return std::abs(sp.length) - std::abs(sp.start_length) > POSITIVE_SHIFT_THR;\n  };\n\n  // check if the shift point is negative (returning) shift\n  const auto isNegative = [&](const auto & sp) {\n    constexpr auto NEGATIVE_SHIFT_THR = -0.1;\n    return std::abs(sp.length) - std::abs(sp.start_length) < NEGATIVE_SHIFT_THR;\n  };\n\n  // combine two shift points. Be careful the order of \"now\" and \"next\".\n  const auto combineShiftPoint = [this](const auto & sp_next, const auto & sp_now) {\n    auto sp_modified = sp_now;\n    setEndData(sp_modified, sp_next.length, sp_next.end, sp_next.end_idx, sp_next.end_longitudinal);\n    sp_modified.parent_ids = concatParentIds(sp_modified.parent_ids, sp_now.parent_ids);\n    return sp_modified;\n  };\n\n  // Check if the merged shift has a conflict with the original shifts.\n  const auto hasViolation = [this](const auto & combined, const auto & combined_src) {\n    constexpr auto VIOLATION_SHIFT_THR = 0.3;\n    for (const auto & sp : combined_src) {\n      const auto combined_shift = lerpShiftLengthOnArc(sp.end_longitudinal, combined);\n      if (sp.length < -0.01 && combined_shift > sp.length + VIOLATION_SHIFT_THR) {\n        return true;\n      }\n      if (sp.length > 0.01 && combined_shift < sp.length - VIOLATION_SHIFT_THR) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // check for all shift points\n  for (size_t i = 0; i < shift_points_orig.size(); ++i) {\n    auto sp_now = shift_points_orig.at(i);\n    sp_now.start_length =\n      shift_points.empty() ? getCurrentLinearShift() : shift_points.back().length;\n\n    if (sp_now.length * sp_now.start_length < -0.01) {\n      DEBUG_PRINT(\"i = %lu, This is avoid shift for opposite direction. take this one\", i);\n      continue;\n    }\n\n    // Do nothing for non-reduce shift point\n    if (!isNegative(sp_now)) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\n        \"i = %lu, positive shift. take this one. sp_now.length * sp_now.start_length = %f\", i,\n        sp_now.length * sp_now.start_length);\n      continue;\n    }\n\n    // The last point is out of target of this function.\n    if (i == shift_points_orig.size() - 1) {\n      shift_points.push_back(sp_now);\n      DEBUG_PRINT(\"i = %lu, last shift. take this one.\", i);\n      continue;\n    }\n\n    // -----------------------------------------------------------------------\n    // ------------ From here, the shift point is \"negative\" -----------------\n    // -----------------------------------------------------------------------\n\n    // if next shift is negative, combine them. loop until combined shift line\n    // exceeds merged shift point.\n    DEBUG_PRINT(\"i = %lu, found negative dist. search.\", i);\n    {\n      auto sp_combined = sp_now;\n      auto sp_combined_prev = sp_combined;\n      AvoidPointArray sp_combined_array{sp_now};\n      size_t j = i + 1;\n      for (; i < shift_points_orig.size(); ++j) {\n        const auto sp_combined = combineShiftPoint(shift_points_orig.at(j), sp_now);\n\n        {\n          std::stringstream ss;\n          ss << \"i = \" << i << \", j = \" << j << \": sp_combined = \" << toStrInfo(sp_combined);\n          DEBUG_PRINT(\"%s\", ss.str().c_str());\n        }\n\n        // it gets positive. Finish merging.\n        if (isPositive(sp_combined)) {\n          shift_points.push_back(sp_combined);\n          DEBUG_PRINT(\"reach positive.\");\n          break;\n        }\n\n        // Still negative, but it violates the original shift points.\n        // Finish with the previous merge result.\n        if (hasViolation(sp_combined, sp_combined_array)) {\n          shift_points.push_back(sp_combined_prev);\n          DEBUG_PRINT(\"violation found.\");\n          --j;\n          break;\n        }\n\n        // Still negative, but it has an enough long distance. Finish merging.\n        const auto nominal_distance = getNominalAvoidanceDistance(sp_combined.getRelativeLength());\n        const auto long_distance =\n          isZero(sp_combined.length) ? nominal_distance : nominal_distance * 5.0;\n        if (sp_combined.getRelativeLongitudinal() > long_distance) {\n          shift_points.push_back(sp_combined);\n          DEBUG_PRINT(\"still negative, but long enough. Threshold = %f\", long_distance);\n          break;\n        }\n\n        // It reaches the last point. Still the shift is sharp, but merge with the current result.\n        if (j == shift_points_orig.size() - 1) {\n          shift_points.push_back(sp_combined);\n          DEBUG_PRINT(\"reach end point.\");\n          break;\n        }\n\n        // Still negative shift, and the distance is not enough. Search next.\n        sp_combined_prev = sp_combined;\n        sp_combined_array.push_back(shift_points_orig.at(j));\n      }\n      i = j;\n      continue;\n    }\n  }\n\n  alignShiftPointsOrder(shift_points);\n\n  DEBUG_PRINT(\"trimSharpReturn: size %lu -> %lu\", shift_points_orig.size(), shift_points.size());\n}\n\nvoid AvoidanceModule::trimTooSharpShift(AvoidPointArray & avoid_points) const\n{\n  if (avoid_points.empty()) {\n    return;\n  }\n\n  AvoidPointArray avoid_points_orig = avoid_points;\n  avoid_points.clear();\n\n  const auto isInJerkLimit = [this](const auto & ap) {\n    const auto required_jerk = path_shifter_.calcJerkFromLatLonDistance(\n      ap.getRelativeLength(), ap.getRelativeLongitudinal(), getSharpAvoidanceEgoSpeed());\n    return std::fabs(required_jerk) < parameters_.max_lateral_jerk;\n  };\n\n  for (size_t i = 0; i < avoid_points_orig.size(); ++i) {\n    auto ap_now = avoid_points_orig.at(i);\n\n    if (isInJerkLimit(ap_now)) {\n      avoid_points.push_back(ap_now);\n      continue;\n    }\n\n    DEBUG_PRINT(\"over jerk is detected: i = %lu\", i);\n    printShiftPoints(AvoidPointArray{ap_now}, \"points with over jerk\");\n\n    // The avoidance_point_now exceeds jerk limit, so merge it with the next avoidance_point.\n    for (size_t j = i + 1; j < avoid_points_orig.size(); ++j) {\n      auto ap_next = avoid_points_orig.at(j);\n      setEndData(ap_now, ap_next.length, ap_next.end, ap_next.end_idx, ap_next.end_longitudinal);\n      if (isInJerkLimit(ap_now)) {\n        avoid_points.push_back(ap_now);\n        DEBUG_PRINT(\"merge finished. i = %lu, j = %lu\", i, j);\n        i = j;  // skip check until j index.\n        break;\n      }\n    }\n  }\n\n  alignShiftPointsOrder(avoid_points);\n\n  DEBUG_PRINT(\"size %lu -> %lu\", avoid_points_orig.size(), avoid_points.size());\n}\n\n/*\n * addReturnShiftPoint\n *\n * Pick up the last shift point, which is the most farthest from ego, from the current candidate\n * avoidance points and registered points in the shifter. If the last shift length of the point is\n * non-zero, add a return-shift to center line from the point. If there is no shift point in\n * candidate avoidance points nor registered points, and base_shift > 0, add a return-shift to\n * center line from ego.\n */\nvoid AvoidanceModule::addReturnShiftPointFromEgo(\n  AvoidPointArray & sp_candidates, AvoidPointArray & current_raw_shift_points) const\n{\n  constexpr double ep = 1.0e-3;\n  const bool has_candidate_point = !sp_candidates.empty();\n  const bool has_registered_point = !path_shifter_.getShiftPoints().empty();\n\n  // If the return-to-center shift points are already registered, do nothing.\n  if (!has_registered_point && std::fabs(getCurrentBaseShift()) < ep) {\n    DEBUG_PRINT(\"No shift points, not base offset. Do not have to add return-shift.\");\n    return;\n  }\n\n  constexpr double RETURN_SHIFT_THRESHOLD = 0.1;\n  DEBUG_PRINT(\"registered last shift = %f\", path_shifter_.getLastShiftLength());\n  if (std::abs(path_shifter_.getLastShiftLength()) < RETURN_SHIFT_THRESHOLD) {\n    DEBUG_PRINT(\"Return shift is already registered. do nothing.\");\n    return;\n  }\n\n  // From here, the return-to-center is not registered. But perhaps the candidate is\n  // already generated.\n\n  // If it has a shift point, add return shift from the existing last shift point.\n  // If not, add return shift from ego point. (prepare distance is considered for both.)\n  ShiftPoint last_sp;  // the return-shift will be generated after the last shift point.\n  {\n    // avoidance points: Yes, shift points: No -> select last avoidance point.\n    if (has_candidate_point && !has_registered_point) {\n      alignShiftPointsOrder(sp_candidates, false);\n      last_sp = sp_candidates.back();\n    }\n\n    // avoidance points: No, shift points: Yes -> select last shift point.\n    if (!has_candidate_point && has_registered_point) {\n      last_sp = fillAdditionalInfo(AvoidPoint{path_shifter_.getLastShiftPoint().get()});\n    }\n\n    // avoidance points: Yes, shift points: Yes -> select the last one from both.\n    if (has_candidate_point && has_registered_point) {\n      alignShiftPointsOrder(sp_candidates, false);\n      const auto & ap = sp_candidates.back();\n      const auto & sp = fillAdditionalInfo(AvoidPoint{path_shifter_.getLastShiftPoint().get()});\n      last_sp = (sp.end_longitudinal > ap.end_longitudinal) ? sp : ap;\n    }\n\n    // avoidance points: No, shift points: No -> set the ego position to the last shift point\n    // so that the return-shift will be generated from ego position.\n    if (!has_candidate_point && !has_registered_point) {\n      last_sp.end = getEgoPose().pose;\n      last_sp.end_idx = avoidance_data_.ego_closest_path_index;\n      last_sp.length = getCurrentBaseShift();\n    }\n  }\n  printShiftPoints(ShiftPointArray{last_sp}, \"last shift point\");\n\n  // There already is a shift point candidates to go back to center line, but it could be too sharp\n  // due to detection noise or timing.\n  // Here the return-shift from ego is added for the in case.\n  if (std::fabs(last_sp.length) < RETURN_SHIFT_THRESHOLD) {\n    const auto current_base_shift = getCurrentShift();\n    if (std::abs(current_base_shift) < ep) {\n      DEBUG_PRINT(\"last shift almost is zero, and current base_shift is zero. do nothing.\");\n      return;\n    }\n\n    // Is there a shift point in the opposite direction of the current_base_shift?\n    //   No  -> we can overwrite the return shift, because the other shift points that decrease\n    //          the shift length are for return-shift.\n    //   Yes -> we can NOT overwrite, because it might be not a return-shift, but a avoiding\n    //          shift to the opposite direction which can not be overwritten by the return-shift.\n    for (const auto & sp : sp_candidates) {\n      if (\n        (current_base_shift > 0.0 && sp.length < -ep) ||\n        (current_base_shift < 0.0 && sp.length > ep)) {\n        DEBUG_PRINT(\n          \"try to put overwrite return shift, but there is shift for opposite direction. Skip \"\n          \"adding return shift.\");\n        return;\n      }\n    }\n\n    // set the return-shift from ego.\n    DEBUG_PRINT(\n      \"return shift already exists, but they are all candidates. Add return shift for overwrite.\");\n    last_sp.end = getEgoPose().pose;\n    last_sp.end_idx = avoidance_data_.ego_closest_path_index;\n    last_sp.length = current_base_shift;\n  }\n\n  const auto & arclength_from_ego = avoidance_data_.arclength_from_ego;\n\n  const auto nominal_prepare_distance = getNominalPrepareDistance();\n  const auto nominal_avoid_distance = getNominalAvoidanceDistance(last_sp.length);\n\n  if (arclength_from_ego.empty()) {\n    return;\n  }\n\n  const auto remaining_distance = arclength_from_ego.back();\n\n  // If the avoidance point has already been set, the return shift must be set after the point.\n  const auto last_sp_distance = avoidance_data_.arclength_from_ego.at(last_sp.end_idx);\n\n  // check if there is enough distance for return.\n  if (last_sp_distance + 1.0 > remaining_distance) {  // tmp: add some small number (+1.0)\n    DEBUG_PRINT(\"No enough distance for return.\");\n    return;\n  }\n\n  // If the remaining distance is not enough, the return shift needs to be shrunk.\n  // (or another option is just to ignore the return-shift.)\n  // But we do not want to change the last shift point, so we will shrink the distance after\n  // the last shift point.\n  //\n  //  The line \"===\" is fixed, \"---\" is scaled.\n  //\n  // [Before Scaling]\n  //  ego              last_sp_end             prepare_end            path_end    avoid_end\n  // ==o====================o----------------------o----------------------o------------o\n  //   |            prepare_dist                   |          avoid_dist               |\n  //\n  // [After Scaling]\n  // ==o====================o------------------o--------------------------o\n  //   |        prepare_dist_scaled            |    avoid_dist_scaled     |\n  //\n  const double variable_prepare_distance =\n    std::max(nominal_prepare_distance - last_sp_distance, 0.0);\n\n  double prepare_distance_scaled = std::max(nominal_prepare_distance, last_sp_distance);\n  double avoid_distance_scaled = nominal_avoid_distance;\n  if (remaining_distance < prepare_distance_scaled + avoid_distance_scaled) {\n    const auto scale = (remaining_distance - last_sp_distance) /\n                       std::max(nominal_avoid_distance + variable_prepare_distance, 0.1);\n    prepare_distance_scaled = last_sp_distance + scale * nominal_prepare_distance;\n    avoid_distance_scaled *= scale;\n    DEBUG_PRINT(\n      \"last_sp_distance = %f, nominal_prepare_distance = %f, nominal_avoid_distance = %f, \"\n      \"remaining_distance = %f, variable_prepare_distance = %f, scale = %f, \"\n      \"prepare_distance_scaled = %f,avoid_distance_scaled = %f\",\n      last_sp_distance, nominal_prepare_distance, nominal_avoid_distance, remaining_distance,\n      variable_prepare_distance, scale, prepare_distance_scaled, avoid_distance_scaled);\n  } else {\n    DEBUG_PRINT(\"there is enough distance. Use nominal for prepare & avoidance.\");\n  }\n\n  // shift point for prepare distance: from last shift to return-start point.\n  if (nominal_prepare_distance > last_sp_distance) {\n    AvoidPoint ap;\n    ap.id = getOriginalShiftPointUniqueId();\n    ap.start_idx = last_sp.end_idx;\n    ap.start = last_sp.end;\n    ap.start_longitudinal = arclength_from_ego.at(ap.start_idx);\n    ap.end_idx = findPathIndexFromArclength(arclength_from_ego, prepare_distance_scaled);\n    ap.end = avoidance_data_.reference_path.points.at(ap.end_idx).point.pose;\n    ap.end_longitudinal = arclength_from_ego.at(ap.end_idx);\n    ap.length = last_sp.length;\n    ap.start_length = last_sp.length;\n    sp_candidates.push_back(ap);\n    printShiftPoints(AvoidPointArray{ap}, \"prepare for return\");\n    debug_data_.extra_return_shift.push_back(ap);\n\n    // TODO(Horibe) think how to store the current object\n    current_raw_shift_points.push_back(ap);\n  }\n\n  // shift point for return to center line\n  {\n    AvoidPoint ap;\n    ap.id = getOriginalShiftPointUniqueId();\n    ap.start_idx = findPathIndexFromArclength(arclength_from_ego, prepare_distance_scaled);\n    ap.start = avoidance_data_.reference_path.points.at(ap.start_idx).point.pose;\n    ap.start_longitudinal = arclength_from_ego.at(ap.start_idx);\n    ap.end_idx = findPathIndexFromArclength(\n      arclength_from_ego, prepare_distance_scaled + avoid_distance_scaled);\n    ap.end = avoidance_data_.reference_path.points.at(ap.end_idx).point.pose;\n    ap.end_longitudinal = arclength_from_ego.at(ap.end_idx);\n    ap.length = 0.0;\n    ap.start_length = last_sp.length;\n    sp_candidates.push_back(ap);\n    printShiftPoints(AvoidPointArray{ap}, \"return point\");\n    debug_data_.extra_return_shift = AvoidPointArray{ap};\n\n    // TODO(Horibe) think how to store the current object\n    current_raw_shift_points.push_back(ap);\n  }\n\n  DEBUG_PRINT(\"Return Shift is added.\");\n}\n\ndouble AvoidanceModule::getRightShiftBound() const\n{\n  // TODO(Horibe) write me. Real lane boundary must be considered here.\n  return -parameters_.max_right_shift_length;\n}\n\ndouble AvoidanceModule::getLeftShiftBound() const\n{\n  // TODO(Horibe) write me. Real lane boundary must be considered here.\n  return parameters_.max_left_shift_length;\n}\n\n// TODO(murooka) judge when and which way to extend drivable area. current implementation is keep\n// extending during avoidance module\n// TODO(murooka) freespace during turning in intersection where there is no neighbour lanes\n// NOTE: Assume that there is no situation where there is an object in the middle lane of more than\n// two lanes since which way to avoid is not obvious\nvoid AvoidanceModule::generateExtendedDrivableArea(ShiftedPath * shifted_path) const\n{\n  const auto & route_handler = planner_data_->route_handler;\n  lanelet::ConstLanelets extended_lanelets = avoidance_data_.current_lanelets;\n\n  {\n    // 0. Extend to right/left of objects\n    for (const auto & obstacle : avoidance_data_.objects) {\n      lanelet::ConstLanelets search_lanelets;\n      auto object_lanelet = obstacle.overhang_lanelet;\n      constexpr bool get_right = true;\n      constexpr bool get_left = true;\n      const bool include_opposite = parameters_.enable_avoidance_over_opposite_direction;\n      if (isOnRight(obstacle)) {\n        search_lanelets = route_handler->getAllSharedLineStringLanelets(\n          object_lanelet, !get_right, get_left, include_opposite);\n      } else {\n        search_lanelets = route_handler->getAllSharedLineStringLanelets(\n          object_lanelet, get_right, !get_left, include_opposite);\n      }\n      extended_lanelets.insert(\n        extended_lanelets.end(), search_lanelets.begin(), search_lanelets.end());\n    }\n  }\n\n  for (const auto & lane : avoidance_data_.current_lanelets) {\n    {  // 1. extend to right/left or adjacent right/left (where lane_change tag = no, but not a\n       // problem to extend for avoidance) lane if it exists\n      // this can be available only if line string is shared\n      const auto opt_right_lane = route_handler->getRightLanelet(lane);\n      const auto opt_left_lane = route_handler->getLeftLanelet(lane);\n\n      if (opt_right_lane) {\n        extended_lanelets.push_back(opt_right_lane.get());\n        continue;\n      } else if (opt_left_lane) {\n        extended_lanelets.push_back(opt_left_lane.get());\n        continue;\n      }\n    }\n\n    {  // 2. when there are multiple turning lanes whose previous lanelet is the same in\n       // intersection\n      const bool update_extended_lanelets = [&]() {\n        // lanelet is not turning lane\n        const std::string turn_direction = lane.attributeOr(\"turn_direction\", \"none\");\n        if (turn_direction != \"right\" && turn_direction != \"left\") {\n          return false;\n        }\n\n        // get previous lane, and return false if previous lane does not exist\n        lanelet::ConstLanelets prev_lanes;\n        if (!route_handler->getPreviousLaneletsWithinRoute(lane, &prev_lanes)) {\n          return false;\n        }\n\n        // get next lanes from the previous lane, and return false if next lanes do not exist\n        const auto next_lanes = route_handler->getNextLanelets(lane);\n        if (next_lanes.empty()) {\n          return false;\n        }\n\n        // look for neighbour lane, where end line of the lane is connected to end line of the\n        // original lane\n        for (const auto & next_lane : next_lanes) {\n          if (lane.id() == next_lane.id()) {\n            continue;\n          }\n\n          const Eigen::Vector2d & next_left_back_point_2d =\n            next_lane.leftBound2d().back().basicPoint();\n          const Eigen::Vector2d & next_right_back_point_2d =\n            next_lane.rightBound2d().back().basicPoint();\n\n          const Eigen::Vector2d & orig_left_back_point_2d = lane.leftBound2d().back().basicPoint();\n          const Eigen::Vector2d & orig_right_back_point_2d =\n            lane.rightBound2d().back().basicPoint();\n\n          constexpr double epsilon = 1e-5;\n          const bool is_neighbour_lane =\n            (next_left_back_point_2d - orig_right_back_point_2d).norm() < epsilon ||\n            (next_right_back_point_2d - orig_left_back_point_2d).norm() < epsilon;\n          if (is_neighbour_lane) {\n            extended_lanelets.push_back(next_lane);\n            return true;\n          }\n        }\n\n        return false;\n      }();\n      if (update_extended_lanelets) {\n        continue;\n      }\n    }\n\n    {  // 3. deal with the problem that line string is not shared to neighbour lanelets in\n       // intersection (for left lane), assuming that points are shared\n      // this part will be removed when the map format is modified correctly wrt sharing line string\n      // since 1 works for this\n      bool update_extended_lanelets = false;\n      const auto & left_lane_candidates =\n        route_handler->getLaneletsFromPoint(lane.leftBound().front());\n      for (const auto & left_lane_candidate : left_lane_candidates) {\n        const Eigen::Vector2d & left_lane_right_back_point_2d =\n          left_lane_candidate.rightBound2d().back().basicPoint();\n        const Eigen::Vector2d & orig_lane_left_back_point_2d =\n          lane.leftBound2d().back().basicPoint();\n\n        const double epsilon = 1e-5;\n        const bool is_neighbour_lane =\n          (left_lane_right_back_point_2d - orig_lane_left_back_point_2d).norm() < epsilon;\n        if (is_neighbour_lane) {\n          extended_lanelets.push_back(left_lane_candidate);\n          update_extended_lanelets = true;\n          break;\n        }\n      }\n      if (update_extended_lanelets) {\n        continue;\n      }\n    }\n\n    {  // 4. deal with the problem that line string is not shared to neighbour lanelets in\n       // intersection (for right lane), assuming that points are shared\n      // this part will be removed if the map format is modified correctly wrt sharing line string\n      // since 1 works for this\n      bool update_extended_lanelets = false;\n      const auto & right_lane_candidates =\n        route_handler->getLaneletsFromPoint(lane.rightBound().front());\n      for (const auto & right_lane_candidate : right_lane_candidates) {\n        const Eigen::Vector2d & right_lane_left_back_point_2d =\n          right_lane_candidate.leftBound2d().back().basicPoint();\n        const Eigen::Vector2d & orig_lane_right_back_point_2d =\n          lane.rightBound2d().back().basicPoint();\n\n        const double epsilon = 1e-5;\n        const bool is_neighbour_lane =\n          (right_lane_left_back_point_2d - orig_lane_right_back_point_2d).norm() < epsilon;\n        if (is_neighbour_lane) {\n          extended_lanelets.push_back(right_lane_candidate);\n          update_extended_lanelets = true;\n          break;\n        }\n      }\n      if (update_extended_lanelets) {\n        continue;\n      }\n    }\n\n    {\n      // 5. if drivable area cannot be extended inside the same-direction lane, extend to even\n      // opposite lane\n      const auto opposite_lanes = route_handler->getRightOppositeLanelets(lane);\n\n      if (!opposite_lanes.empty()) {\n        for (const auto & opposite_lane : opposite_lanes) {\n          extended_lanelets.push_back(opposite_lane);\n        }\n        continue;\n      }\n    }\n\n    {  // 6. deal with the problem that line string is not shared to neighbour opposite lanelet,\n       // assuming that points are shared\n      // this part will be removed when the map format is modified correctly wrt sharing line string\n      // since 5 works for this\n      bool update_extended_lanelets = false;\n      const auto & opposite_lane_candidates =\n        route_handler->getLaneletsFromPoint(lane.rightBound().front());\n      for (const auto & opposite_lane_candidate : opposite_lane_candidates) {\n        const Eigen::Vector2d & opposite_lane_right_front_point_2d =\n          opposite_lane_candidate.rightBound2d().front().basicPoint();\n        const Eigen::Vector2d & orig_lane_right_back_point_2d =\n          lane.rightBound2d().back().basicPoint();\n\n        const double epsilon = 1e-5;\n        const bool is_neighbour_lane =\n          (opposite_lane_right_front_point_2d - orig_lane_right_back_point_2d).norm() < epsilon;\n        if (is_neighbour_lane) {\n          extended_lanelets.push_back(opposite_lane_candidate);\n          update_extended_lanelets = true;\n          break;\n        }\n      }\n      if (update_extended_lanelets) {\n        continue;\n      }\n    }\n  }\n\n  {\n    const auto & p = planner_data_->parameters;\n    shifted_path->path.drivable_area = util::generateDrivableArea(\n      extended_lanelets, p.drivable_area_resolution, p.vehicle_length, planner_data_);\n  }\n}\n\nvoid AvoidanceModule::modifyPathVelocityToPreventAccelerationOnAvoidance(ShiftedPath & path) const\n{\n  const auto ego_idx = avoidance_data_.ego_closest_path_index;\n  const auto N = path.shift_length.size();\n\n  // find first shift-change point from ego\n  constexpr auto SHIFT_DIFF_THR = 0.1;\n  size_t target_idx = N;\n  const auto current_shift = path.shift_length.at(ego_idx);\n  for (size_t i = ego_idx + 1; i < N; ++i) {\n    if (std::abs(path.shift_length.at(i) - current_shift) > SHIFT_DIFF_THR) {\n      // this index do not have to be accurate, so it can be i or i + 1.\n      // but if the ego point is already on the shift-change point, ego index should be a target_idx\n      // so that the distance for acceleration will be 0 and the ego speed is directly applied\n      // to the path velocity (no acceleration while avoidance)\n      target_idx = i - 1;\n      break;\n    }\n  }\n  if (target_idx == N) {\n    DEBUG_PRINT(\"shift length has no changes. No velocity limit is applied.\");\n    return;\n  }\n\n  // calc time to the shift-change point\n  constexpr auto NO_ACCEL_TIME_THR = 3.0;\n  const auto s = avoidance_data_.arclength_from_ego.at(target_idx) -\n                 avoidance_data_.arclength_from_ego.at(ego_idx);\n  const auto t = s / std::max(getEgoSpeed(), 1.0);\n  if (t > NO_ACCEL_TIME_THR) {\n    DEBUG_PRINT(\n      \"shift point is far (s: %f, t: %f, ego_i: %lu, target_i: %lu). No velocity limit is applied.\",\n      s, t, ego_idx, target_idx);\n    return;\n  }\n\n  // calc max velocity with given acceleration\n  const auto v0 = getEgoSpeed();\n  const auto vmax = std::max(\n    parameters_.min_avoidance_speed_for_acc_prevention,\n    std::sqrt(v0 * v0 + 2.0 * s * parameters_.max_avoidance_acceleration));\n\n  // apply velocity limit\n  constexpr size_t VLIM_APPLY_IDX_MARGIN = 0;\n  for (size_t i = ego_idx + VLIM_APPLY_IDX_MARGIN; i < N; ++i) {\n    path.path.points.at(i).point.longitudinal_velocity_mps =\n      std::min(path.path.points.at(i).point.longitudinal_velocity_mps, static_cast<float>(vmax));\n  }\n\n  DEBUG_PRINT(\n    \"s: %f, t: %f, v0: %f, a: %f, vmax: %f, ego_i: %lu, target_i: %lu\", s, t, v0,\n    parameters_.max_avoidance_acceleration, vmax, ego_idx, target_idx);\n}\n\n// TODO(Horibe) clean up functions: there is a similar code in util as well.\nPathWithLaneId AvoidanceModule::calcCenterLinePath(\n  const std::shared_ptr<const PlannerData> & planner_data, const PoseStamped & pose) const\n{\n  const auto & p = planner_data->parameters;\n  const auto & route_handler = planner_data->route_handler;\n\n  PathWithLaneId centerline_path;\n\n  // special for avoidance: take behind distance upt ot shift-start-point if it exist.\n  const auto longest_dist_to_shift_point = [&]() {\n    double max_dist = 0.0;\n    for (const auto & pnt : path_shifter_.getShiftPoints()) {\n      max_dist = std::max(max_dist, calcDistance2d(getEgoPose(), pnt.start));\n    }\n    for (const auto & sp : registered_raw_shift_points_) {\n      max_dist = std::max(max_dist, calcDistance2d(getEgoPose(), sp.start));\n    }\n    return max_dist;\n  }();\n\n  printShiftPoints(path_shifter_.getShiftPoints(), \"path_shifter_.getShiftPoints()\");\n  printShiftPoints(registered_raw_shift_points_, \"registered_raw_shift_points_\");\n\n  const auto extra_margin = 10.0;  // Since distance does not consider arclength, but just line.\n  const auto backward_length =\n    std::max(p.backward_path_length, longest_dist_to_shift_point + extra_margin);\n\n  DEBUG_PRINT(\n    \"p.backward_path_length = %f, longest_dist_to_shift_point = %f, backward_length = %f\",\n    p.backward_path_length, longest_dist_to_shift_point, backward_length);\n\n  const lanelet::ConstLanelets current_lanes =\n    calcLaneAroundPose(planner_data, pose.pose, backward_length);\n  centerline_path = util::getCenterLinePath(\n    *route_handler, current_lanes, pose.pose, backward_length, p.forward_path_length, p);\n\n  // for debug: check if the path backward distance is same as the desired length.\n  // {\n  //   const auto back_to_ego = tier4_autoware_utils::calcSignedArcLength(\n  //     centerline_path.points, centerline_path.points.front().point.pose.position,\n  //     getEgoPosition());\n  //   RCLCPP_INFO(getLogger(), \"actual back_to_ego distance = %f\", back_to_ego);\n  // }\n\n  centerline_path.header = route_handler->getRouteHeader();\n\n  return centerline_path;\n}\n\nboost::optional<AvoidPoint> AvoidanceModule::calcIntersectionShiftPoint(\n  const AvoidancePlanningData & data) const\n{\n  boost::optional<PathPointWithLaneId> intersection_point{};\n  for (const auto & p : avoidance_data_.reference_path.points) {\n    for (const auto & id : p.lane_ids) {\n      const lanelet::ConstLanelet ll = planner_data_->route_handler->getLaneletsFromId(id);\n      std::string turn_direction = ll.attributeOr(\"turn_direction\", \"else\");\n      if (turn_direction == \"right\" || turn_direction == \"left\") {\n        intersection_point = p;\n        RCLCPP_INFO(getLogger(), \"intersection is found.\");\n        break;\n      }\n    }\n    if (intersection_point) {\n      break;\n    }\n  }\n\n  const auto calcBehindPose = [&data](const Point & p, const double dist) {\n    const auto & path = data.reference_path;\n    const size_t start = findNearestIndex(path.points, p);\n    double sum = 0.0;\n    for (size_t i = start - 1; i > 1; --i) {\n      sum += calcDistance2d(path.points.at(i), path.points.at(i + 1));\n      if (sum > dist) {\n        return path.points.at(i).point.pose;\n      }\n    }\n    return path.points.at(0).point.pose;\n  };\n\n  const auto intersection_shift_point = [&]() {\n    boost::optional<AvoidPoint> shift_point{};\n    if (!intersection_point) {\n      RCLCPP_INFO(getLogger(), \"No intersection.\");\n      return shift_point;\n    }\n\n    const double ego_to_intersection_dist = calcSignedArcLength(\n      data.reference_path.points, getEgoPosition(), intersection_point->point.pose.position);\n\n    if (ego_to_intersection_dist <= 5.0) {\n      RCLCPP_INFO(getLogger(), \"No enough margin to intersection.\");\n      return shift_point;\n    }\n\n    // Search obstacles around the intersection.\n    // If it exists, use its shift distance on the intersection.\n    constexpr double intersection_obstacle_check_dist = 10.0;\n    constexpr double intersection_shift_margin = 1.0;\n\n    double shift_length = 0.0;  // default (no obstacle) is zero.\n    for (const auto & obj : avoidance_data_.objects) {\n      if (\n        std::abs(obj.longitudinal - ego_to_intersection_dist) > intersection_obstacle_check_dist) {\n        continue;\n      }\n      if (isOnRight(obj)) {\n        continue;  // TODO(Horibe) Now only think about the left side obstacle.\n      }\n      shift_length = std::min(shift_length, obj.overhang_dist - intersection_shift_margin);\n    }\n    RCLCPP_INFO(getLogger(), \"Intersection shift_length = %f\", shift_length);\n\n    AvoidPoint p{};\n    p.length = shift_length;\n    p.start =\n      calcBehindPose(intersection_point->point.pose.position, intersection_obstacle_check_dist);\n    p.end = intersection_point->point.pose;\n    shift_point = p;\n    return shift_point;\n  }();\n\n  return intersection_shift_point;\n}\n\nBehaviorModuleOutput AvoidanceModule::plan()\n{\n  DEBUG_PRINT(\"AVOIDANCE plan\");\n\n  const auto shift_points = calcShiftPoints(current_raw_shift_points_, debug_data_);\n\n  const auto new_shift_points = findNewShiftPoint(shift_points, path_shifter_);\n\n  /**\n   * Has new shift point?\n   *   Yes -> Is it approved?\n   *       Yes -> add the shift point.\n   *       No  -> set approval_handler to WAIT_APPROVAL state.\n   *   No -> waiting approval?\n   *       Yes -> clear WAIT_APPROVAL state.\n   *       No  -> do nothing.\n   */\n  if (new_shift_points) {\n    debug_data_.new_shift_points = *new_shift_points;\n    DEBUG_PRINT(\"new_shift_points size = %lu\", new_shift_points->size());\n    printShiftPoints(*new_shift_points, \"new_shift_points\");\n    addShiftPointIfApproved(*new_shift_points);\n  } else if (approval_handler_.isWaitingApproval()) {\n    approval_handler_.clearWaitApproval();\n  }\n\n  // generate path with shift points that have been inserted.\n  auto avoidance_path = generateAvoidancePath(path_shifter_);\n  debug_data_.output_shift = avoidance_path.shift_length;\n\n  // Drivable area generation.\n  generateExtendedDrivableArea(&avoidance_path);\n\n  // modify max speed to prevent acceleration in avoidance maneuver.\n  modifyPathVelocityToPreventAccelerationOnAvoidance(avoidance_path);\n\n  // post processing\n  {\n    postProcess(path_shifter_);  // remove old shift points\n    prev_output_ = avoidance_path;\n    prev_linear_shift_path_ = toShiftedPath(avoidance_data_.reference_path);\n    path_shifter_.generate(&prev_linear_shift_path_, true, SHIFT_TYPE::LINEAR);\n    prev_reference_ = avoidance_data_.reference_path;\n    if (parameters_.publish_debug_marker) {\n      setDebugData(path_shifter_, debug_data_);\n    }\n  }\n\n  BehaviorModuleOutput output;\n  output.turn_signal_info = calcTurnSignalInfo(avoidance_path);\n  // sparse resampling for computational cost\n  {\n    avoidance_path.path =\n      util::resamplePathWithSpline(avoidance_path.path, parameters_.resample_interval_for_output);\n  }\n  output.path = std::make_shared<PathWithLaneId>(avoidance_path.path);\n\n  clipPathLength(*output.path);\n\n  DEBUG_PRINT(\"exit plan(): set prev output (back().lat = %f)\", prev_output_.shift_length.back());\n\n  return output;\n}\n\nPathWithLaneId AvoidanceModule::planCandidate() const\n{\n  DEBUG_PRINT(\"AVOIDANCE planCandidate start\");\n\n  auto path_shifter = path_shifter_;\n  auto debug_data = debug_data_;\n  auto current_raw_shift_points = current_raw_shift_points_;\n\n  const auto shift_points = calcShiftPoints(current_raw_shift_points, debug_data);\n  const auto new_shift_points = findNewShiftPoint(shift_points, path_shifter);\n  if (new_shift_points) {\n    addNewShiftPoints(path_shifter, *new_shift_points);\n  }\n\n  auto shifted_path = generateAvoidancePath(path_shifter);\n\n  if (new_shift_points) {  // clip from shift start index for visualize\n    clipByMinStartIdx(*new_shift_points, shifted_path.path);\n  }\n\n  clipPathLength(shifted_path.path);\n\n  return shifted_path.path;\n}\n\nBehaviorModuleOutput AvoidanceModule::planWaitingApproval()\n{\n  // we can execute the plan() since it handles the approval appropriately.\n  BehaviorModuleOutput out = plan();\n  out.path_candidate = std::make_shared<PathWithLaneId>(planCandidate());\n  return out;\n}\n\nvoid AvoidanceModule::addShiftPointIfApproved(const AvoidPointArray & shift_points)\n{\n  if (approval_handler_.isApproved()) {\n    DEBUG_PRINT(\"We want to add this shift point, and approved. ADD SHIFT POINT!\");\n    const size_t prev_size = path_shifter_.getShiftPointsSize();\n    addNewShiftPoints(path_shifter_, shift_points);\n\n    // register original points for consistency\n    registerRawShiftPoints(shift_points);\n\n    DEBUG_PRINT(\"shift_point size: %lu -> %lu\", prev_size, path_shifter_.getShiftPointsSize());\n\n    // use this approval.\n    approval_handler_.clearApproval();  // TODO(Horibe) will be fixed with service-call?\n  } else {\n    DEBUG_PRINT(\"We want to add this shift point, but NOT approved. waiting...\");\n    approval_handler_.waitApproval();\n  }\n}\n\n/**\n * set new shift points. remove old shift points if it has a conflict.\n */\nvoid AvoidanceModule::addNewShiftPoints(\n  PathShifter & path_shifter, const AvoidPointArray & new_shift_points) const\n{\n  ShiftPointArray future = toShiftPointArray(new_shift_points);\n\n  size_t min_start_idx = std::numeric_limits<size_t>::max();\n  for (const auto & sp : new_shift_points) {\n    min_start_idx = std::min(min_start_idx, sp.start_idx);\n  }\n\n  const auto current_shift_points = path_shifter.getShiftPoints();\n\n  DEBUG_PRINT(\"min_start_idx = %lu\", min_start_idx);\n\n  // Remove shift points that starts later than the new_shift_point from path_shifter.\n  //\n  // Why? Because shifter sorts by start position and applies shift points, so if there is a\n  // shift point that starts after the one you are going to put in, new one will be affected\n  // by the old one.\n  //\n  // Is it ok? This is a situation where the vehicle was originally going to avoid at the farther\n  // point, but decided to avoid it at a closer point. In this case, it is reasonable to cancel the\n  // farther avoidance.\n  for (const auto & sp : current_shift_points) {\n    if (sp.start_idx >= min_start_idx) {\n      DEBUG_PRINT(\n        \"sp.start_idx = %lu, this sp starts after new proposal. remove this one.\", sp.start_idx);\n    } else {\n      DEBUG_PRINT(\"sp.start_idx = %lu, no conflict. keep this one.\", sp.start_idx);\n      future.push_back(sp);\n    }\n  }\n\n  path_shifter.setShiftPoints(future);\n}\n\nboost::optional<AvoidPointArray> AvoidanceModule::findNewShiftPoint(\n  const AvoidPointArray & candidates, const PathShifter & shifter) const\n{\n  (void)shifter;\n\n  if (candidates.empty()) {\n    DEBUG_PRINT(\"shift candidates is empty. return None.\");\n    return {};\n  }\n\n  printShiftPoints(candidates, \"findNewShiftPoint: candidates\");\n\n  // Retrieve the subsequent linear shift point from the given index point.\n  const auto getShiftPointWithSubsequentStraight = [this, &candidates](size_t i) {\n    AvoidPointArray subsequent{candidates.at(i)};\n    for (size_t j = i + 1; j < candidates.size(); ++j) {\n      const auto next_shift = candidates.at(j);\n      if (std::abs(next_shift.getRelativeLength()) < 1.0e-2) {\n        subsequent.push_back(next_shift);\n        DEBUG_PRINT(\"j = %lu, relative shift is zero. add together.\", j);\n      } else {\n        DEBUG_PRINT(\"j = %lu, relative shift is not zero = %f.\", j, next_shift.getRelativeLength());\n        break;\n      }\n    }\n    return subsequent;\n  };\n\n  const auto calcJerk = [this](const auto & ap) {\n    return path_shifter_.calcJerkFromLatLonDistance(\n      ap.getRelativeLength(), ap.getRelativeLongitudinal(), getSharpAvoidanceEgoSpeed());\n  };\n\n  for (size_t i = 0; i < candidates.size(); ++i) {\n    const auto & candidate = candidates.at(i);\n    std::stringstream ss;\n    ss << \"i = \" << i << \", id = \" << candidate.id;\n    const auto pfx = ss.str().c_str();\n\n    if (prev_reference_.points.size() != prev_linear_shift_path_.path.points.size()) {\n      throw std::logic_error(\"prev_reference_ and prev_linear_shift_path_ must have same size.\");\n    }\n\n    // TODO(Horibe): this code prohibits the changes on ego pose. Think later.\n    // if (candidate.start_idx < avoidance_data_.ego_closest_path_index) {\n    //   DEBUG_PRINT(\"%s, start_idx is behind ego. skip.\", pfx);\n    //   continue;\n    // }\n\n    if (calcJerk(candidate) > parameters_.max_lateral_jerk) {\n      DEBUG_PRINT(\"%s, this shift exceeds jerk limit (%f). skip.\", pfx, calcJerk(candidate));\n      continue;\n    }\n\n    const auto current_shift = prev_linear_shift_path_.shift_length.at(\n      findNearestIndex(prev_reference_.points, candidate.end.position));\n\n    // TODO(Horibe) test fails with this print. why?\n    // DEBUG_PRINT(\"%s, shift current: %f, candidate: %f\", pfx, current_shift, candidate.length);\n\n    const auto new_point_threshold = parameters_.avoidance_execution_lateral_threshold;\n    if (std::abs(candidate.length - current_shift) > new_point_threshold) {\n      DEBUG_PRINT(\n        \"%s, New shift point is found!!! shift change: %f -> %f\", pfx, current_shift,\n        candidate.length);\n      return getShiftPointWithSubsequentStraight(i);\n    }\n  }\n\n  DEBUG_PRINT(\"No new shift point exists.\");\n  return {};\n}\n\ndouble AvoidanceModule::getEgoSpeed() const\n{\n  return std::abs(planner_data_->self_odometry->twist.twist.linear.x);\n}\n\ndouble AvoidanceModule::getNominalAvoidanceEgoSpeed() const\n{\n  return std::max(getEgoSpeed(), parameters_.min_nominal_avoidance_speed);\n}\ndouble AvoidanceModule::getSharpAvoidanceEgoSpeed() const\n{\n  return std::max(getEgoSpeed(), parameters_.min_sharp_avoidance_speed);\n}\n\nPoint AvoidanceModule::getEgoPosition() const { return planner_data_->self_pose->pose.position; }\n\nPoseStamped AvoidanceModule::getEgoPose() const { return *(planner_data_->self_pose); }\n\nPoseStamped AvoidanceModule::getUnshiftedEgoPose(const ShiftedPath & prev_path) const\n{\n  const auto ego_pose = getEgoPose();\n\n  if (prev_path.path.points.empty()) {\n    return ego_pose;\n  }\n\n  // un-shifted fot current ideal pose\n  const auto closest = findNearestIndex(prev_path.path.points, ego_pose.pose.position);\n\n  PoseStamped unshifted_pose = ego_pose;\n  unshifted_pose.pose.orientation = prev_path.path.points.at(closest).point.pose.orientation;\n\n  util::shiftPose(&unshifted_pose.pose, -prev_path.shift_length.at(closest));\n  unshifted_pose.pose.orientation = ego_pose.pose.orientation;\n\n  return unshifted_pose;\n}\n\ndouble AvoidanceModule::getNominalAvoidanceDistance(const double shift_length) const\n{\n  const auto & p = parameters_;\n  const auto distance_by_jerk = path_shifter_.calcLongitudinalDistFromJerk(\n    shift_length, parameters_.nominal_lateral_jerk, getNominalAvoidanceEgoSpeed());\n\n  return std::max(p.min_avoidance_distance, distance_by_jerk);\n}\n\ndouble AvoidanceModule::getSharpAvoidanceDistance(const double shift_length) const\n{\n  const auto & p = parameters_;\n  const auto distance_by_jerk = path_shifter_.calcLongitudinalDistFromJerk(\n    shift_length, parameters_.max_lateral_jerk, getSharpAvoidanceEgoSpeed());\n\n  return std::max(p.min_avoidance_distance, distance_by_jerk);\n}\n\ndouble AvoidanceModule::getNominalPrepareDistance() const\n{\n  const auto & p = parameters_;\n  const auto epsilon_m = 0.01;  // for floating error to pass \"has_enough_distance\" check.\n  const auto nominal_distance = std::max(getEgoSpeed() * p.prepare_time, p.min_prepare_distance);\n  return nominal_distance + epsilon_m;\n}\n\nShiftedPath AvoidanceModule::generateAvoidancePath(PathShifter & path_shifter) const\n{\n  DEBUG_PRINT(\"path_shifter: base shift = %f\", getCurrentBaseShift());\n  printShiftPoints(path_shifter.getShiftPoints(), \"path_shifter shift points\");\n\n  ShiftedPath shifted_path;\n  if (!path_shifter.generate(&shifted_path)) {\n    RCLCPP_ERROR(getLogger(), \"failed to generate shifted path.\");\n    return toShiftedPath(avoidance_data_.reference_path);\n  }\n\n  return shifted_path;\n}\n\nvoid AvoidanceModule::postProcess(PathShifter & path_shifter) const\n{\n  path_shifter.removeBehindShiftPointAndSetBaseOffset(getEgoPosition());\n}\n\nvoid AvoidanceModule::updateData()\n{\n  debug_data_ = DebugData();\n  avoidance_data_ = calcAvoidancePlanningData(debug_data_);\n\n  // TODO(Horibe): this is not tested yet, disable now.\n  updateRegisteredObject(avoidance_data_.objects);\n  CompensateDetectionLost(avoidance_data_.objects);\n\n  path_shifter_.setPath(avoidance_data_.reference_path);\n\n  // update registered shift point for new reference path & remove past objects\n  updateRegisteredRawShiftPoints();\n\n  // for the first time\n  if (prev_output_.path.points.empty()) {\n    prev_output_.path = avoidance_data_.reference_path;\n    prev_output_.shift_length = std::vector<double>(prev_output_.path.points.size(), 0.0);\n  }\n  if (prev_linear_shift_path_.path.points.empty()) {\n    prev_linear_shift_path_.path = avoidance_data_.reference_path;\n    prev_linear_shift_path_.shift_length =\n      std::vector<double>(prev_linear_shift_path_.path.points.size(), 0.0);\n  }\n  if (prev_reference_.points.empty()) {\n    prev_reference_ = avoidance_data_.reference_path;\n  }\n}\n\nstd::string getUuidStr(const ObjectData & obj)\n{\n  return std::to_string(obj.object.object_id.uuid.at(0)) +\n         std::to_string(obj.object.object_id.uuid.at(1)) +\n         std::to_string(obj.object.object_id.uuid.at(2));\n}\n\nstd::string getUuidStr(const ObjectDataArray & objs)\n{\n  std::stringstream ss;\n  for (const auto & o : objs) {\n    ss << getUuidStr(o) << \", \";\n  }\n  return ss.str();\n}\n\n/*\n * updateRegisteredObject\n *\n * Same object is observed this time -> update registered object with the new one.\n * Not observed -> increment the lost_count. if it exceeds the threshold, remove it.\n * How to check if it is same object?\n *   - it has same ID\n *   - it has different id, but sn object is found around similar position\n */\nvoid AvoidanceModule::updateRegisteredObject(const ObjectDataArray & now_objects)\n{\n  const auto updateIfDetectedNow = [&now_objects, this](auto & registered_object) {\n    const auto & n = now_objects;\n    const auto r_id = registered_object.object.object_id;\n    const auto same_id_obj = std::find_if(\n      n.begin(), n.end(), [&r_id](const auto & o) { return o.object.object_id == r_id; });\n\n    // same id object is detected. update registered.\n    if (same_id_obj != n.end()) {\n      registered_object = *same_id_obj;\n      return true;\n    }\n\n    constexpr auto POS_THR = 1.5;\n    const auto r_pos = registered_object.object.kinematics.initial_pose_with_covariance.pose;\n    const auto similar_pos_obj = std::find_if(n.begin(), n.end(), [&](const auto & o) {\n      return calcDistance2d(r_pos, o.object.kinematics.initial_pose_with_covariance.pose) < POS_THR;\n    });\n\n    // same id object is not detected, but object is found around registered. update registered.\n    if (similar_pos_obj != n.end()) {\n      registered_object = *similar_pos_obj;\n      return true;\n    }\n\n    // Same ID nor similar position object does not found.\n    return false;\n  };\n\n  // -- check registered_objects, remove if lost_count exceeds limit. --\n  for (int i = static_cast<int>(registered_objects_.size()) - 1; i >= 0; --i) {\n    auto & r = registered_objects_.at(i);\n    const std::string s = getUuidStr(r);\n\n    // registered object is not detected this time. lost count up.\n    if (!updateIfDetectedNow(r)) {\n      ++r.lost_count;\n\n      // lost count exceeds threshold. remove object from register.\n      if (r.lost_count > parameters_.object_hold_max_count) {\n        registered_objects_.erase(registered_objects_.begin() + i);\n      }\n    }\n  }\n\n  const auto isAlreadyRegistered = [this](const auto & n_id) {\n    const auto & r = registered_objects_;\n    return std::any_of(\n      r.begin(), r.end(), [&n_id](const auto & o) { return o.object.object_id == n_id; });\n  };\n\n  // -- check now_objects, add it if it has new object id --\n  for (const auto now_obj : now_objects) {\n    if (!isAlreadyRegistered(now_obj.object.object_id)) {\n      registered_objects_.push_back(now_obj);\n    }\n  }\n}\n\n/*\n * CompensateDetectionLost\n *\n * add registered object if the now_objects does not contain the same object_id.\n *\n */\nvoid AvoidanceModule::CompensateDetectionLost(ObjectDataArray & now_objects) const\n{\n  const auto old_size = now_objects.size();  // for debug\n\n  const auto isDetectedNow = [&](const auto & r_id) {\n    const auto & n = now_objects;\n    return std::any_of(\n      n.begin(), n.end(), [&r_id](const auto & o) { return o.object.object_id == r_id; });\n  };\n\n  for (const auto & registered : registered_objects_) {\n    if (!isDetectedNow(registered.object.object_id)) {\n      now_objects.push_back(registered);\n    }\n  }\n  DEBUG_PRINT(\"object size: %lu -> %lu\", old_size, now_objects.size());\n}\n\nvoid AvoidanceModule::onEntry()\n{\n  DEBUG_PRINT(\"AVOIDANCE onEntry. wait approval!\");\n  initVariables();\n  current_state_ = BT::NodeStatus::SUCCESS;\n  approval_handler_.waitApproval();\n}\n\nvoid AvoidanceModule::onExit()\n{\n  DEBUG_PRINT(\"AVOIDANCE onExit\");\n  initVariables();\n  current_state_ = BT::NodeStatus::IDLE;\n  approval_handler_.clearWaitApproval();\n}\n\nvoid AvoidanceModule::setParameters(const AvoidanceParameters & parameters)\n{\n  parameters_ = parameters;\n}\n\nvoid AvoidanceModule::initVariables()\n{\n  prev_output_ = ShiftedPath();\n  prev_linear_shift_path_ = ShiftedPath();\n  prev_reference_ = PathWithLaneId();\n  path_shifter_ = PathShifter{};\n\n  debug_data_ = DebugData();\n\n  registered_raw_shift_points_ = {};\n  current_raw_shift_points_ = {};\n  original_unique_id = 0;\n}\n\nvoid AvoidanceModule::clipPathLength(PathWithLaneId & path) const\n{\n  const double forward = planner_data_->parameters.forward_path_length;\n  const double backward = planner_data_->parameters.backward_path_length;\n\n  util::clipPathLength(path, getEgoPosition(), forward, backward);\n}\n\nbool AvoidanceModule::isTargetObjectType(const PredictedObject & object) const\n{\n  using autoware_auto_perception_msgs::msg::ObjectClassification;\n  const auto t = util::getHighestProbLabel(object.classification);\n  const auto is_object_type =\n    ((t == ObjectClassification::CAR && parameters_.avoid_car) ||\n     (t == ObjectClassification::TRUCK && parameters_.avoid_truck) ||\n     (t == ObjectClassification::BUS && parameters_.avoid_bus) ||\n     (t == ObjectClassification::TRAILER && parameters_.avoid_trailer) ||\n     (t == ObjectClassification::UNKNOWN && parameters_.avoid_unknown) ||\n     (t == ObjectClassification::BICYCLE && parameters_.avoid_bicycle) ||\n     (t == ObjectClassification::MOTORCYCLE && parameters_.avoid_motorcycle) ||\n     (t == ObjectClassification::PEDESTRIAN && parameters_.avoid_pedestrian));\n  return is_object_type;\n}\n\nTurnSignalInfo AvoidanceModule::calcTurnSignalInfo(const ShiftedPath & path) const\n{\n  TurnSignalInfo turn_signal;\n\n  const auto shift_points = path_shifter_.getShiftPoints();\n  if (shift_points.empty()) {\n    return {};\n  }\n\n  const auto latest_shift_point = shift_points.front();  // assuming it is sorted.\n\n  const auto turn_info = util::getPathTurnSignal(\n    avoidance_data_.current_lanelets, path, latest_shift_point, planner_data_->self_pose->pose,\n    planner_data_->self_odometry->twist.twist.linear.x, planner_data_->parameters,\n    parameters_.avoidance_search_distance);\n\n  // Set turn signal if the vehicle across the lane.\n  if (!path.shift_length.empty()) {\n    if (isAvoidancePlanRunning()) {\n      turn_signal.turn_signal.command = turn_info.first.command;\n    }\n  }\n\n  // calc distance from ego to latest_shift_point end point.\n  if (turn_info.second >= 0.0) {\n    turn_signal.signal_distance = turn_info.second;\n  }\n\n  return turn_signal;\n}\n\ndouble AvoidanceModule::getCurrentShift() const\n{\n  return prev_output_.shift_length.at(findNearestIndex(prev_output_.path.points, getEgoPosition()));\n}\ndouble AvoidanceModule::getCurrentLinearShift() const\n{\n  return prev_linear_shift_path_.shift_length.at(\n    findNearestIndex(prev_linear_shift_path_.path.points, getEgoPosition()));\n}\n\nvoid AvoidanceModule::setDebugData(const PathShifter & shifter, const DebugData & debug)\n{\n  using marker_utils::createAvoidanceObjectsMarkerArray;\n  using marker_utils::createAvoidPointMarkerArray;\n  using marker_utils::createLaneletsAreaMarkerArray;\n  using marker_utils::createObjectsMarkerArray;\n  using marker_utils::createOvehangFurthestLineStringMarkerArray;\n  using marker_utils::createPathMarkerArray;\n  using marker_utils::createPoseMarkerArray;\n  using marker_utils::createShiftLengthMarkerArray;\n  using marker_utils::createShiftPointMarkerArray;\n  using marker_utils::makeOverhangToRoadShoulderMarkerArray;\n\n  debug_marker_.markers.clear();\n\n  const auto add = [this](const MarkerArray & added) {\n    tier4_autoware_utils::appendMarkerArray(added, &debug_marker_);\n  };\n\n  const auto addAvoidPoint =\n    [&](const AvoidPointArray & ap_arr, const auto & ns, auto r, auto g, auto b, double w = 0.1) {\n      add(createAvoidPointMarkerArray(ap_arr, ns, r, g, b, w));\n    };\n\n  const auto addShiftPoint =\n    [&](const ShiftPointArray & sp_arr, const auto & ns, auto r, auto g, auto b, double w = 0.1) {\n      add(createShiftPointMarkerArray(sp_arr, shifter.getBaseOffset(), ns, r, g, b, w));\n    };\n\n  const auto & path = avoidance_data_.reference_path;\n  add(createPathMarkerArray(debug.center_line, \"centerline\", 0, 0.0, 0.5, 0.9));\n  add(createPathMarkerArray(path, \"centerline_resampled\", 0, 0.0, 0.9, 0.5));\n  add(createPathMarkerArray(prev_linear_shift_path_.path, \"prev_linear_shift\", 0, 0.5, 0.4, 0.6));\n  add(createPoseMarkerArray(avoidance_data_.reference_pose, \"reference_pose\", 0, 0.9, 0.3, 0.3));\n\n  add(createLaneletsAreaMarkerArray(*debug.current_lanelets, \"current_lanelet\", 0.0, 1.0, 0.0));\n  add(createLaneletsAreaMarkerArray(*debug.expanded_lanelets, \"expanded_lanelet\", 0.8, 0.8, 0.0));\n  add(createAvoidanceObjectsMarkerArray(avoidance_data_.objects, \"avoidance_object\"));\n  add(makeOverhangToRoadShoulderMarkerArray(avoidance_data_.objects));\n  add(createOvehangFurthestLineStringMarkerArray(\n    *debug.farthest_linestring_from_overhang, \"farthest_linestring_from_overhang\", 1.0, 0.0, 1.0));\n\n  // parent object info\n  addAvoidPoint(debug.registered_raw_shift, \"p_registered_shift\", 0.8, 0.8, 0.0);\n  addAvoidPoint(debug.current_raw_shift, \"p_current_raw_shift\", 0.5, 0.2, 0.2);\n  addAvoidPoint(debug.extra_return_shift, \"p_extra_return_shift\", 0.0, 0.5, 0.8);\n\n  // merged shift\n  const auto & linear_shift = prev_linear_shift_path_.shift_length;\n  add(createShiftLengthMarkerArray(debug.pos_shift, path, \"m_pos_shift_line\", 0, 0.7, 0.5));\n  add(createShiftLengthMarkerArray(debug.neg_shift, path, \"m_neg_shift_line\", 0, 0.5, 0.7));\n  add(createShiftLengthMarkerArray(debug.total_shift, path, \"m_total_shift_line\", 0.99, 0.4, 0.2));\n  add(createShiftLengthMarkerArray(debug.output_shift, path, \"m_output_shift_line\", 0.8, 0.8, 0.2));\n  add(createShiftLengthMarkerArray(linear_shift, path, \"m_output_linear_line\", 0.9, 0.3, 0.3));\n\n  // child shift points\n  addAvoidPoint(debug.merged, \"c_0_merged\", 0.345, 0.968, 1.0);\n  addAvoidPoint(debug.trim_similar_grad_shift, \"c_1_trim_similar_grad_shift\", 0.976, 0.328, 0.910);\n  addAvoidPoint(debug.quantized, \"c_2_quantized\", 0.505, 0.745, 0.969);\n  addAvoidPoint(debug.trim_small_shift, \"c_3_trim_small_shift\", 0.663, 0.525, 0.941);\n  addAvoidPoint(\n    debug.trim_similar_grad_shift_second, \"c_4_trim_similar_grad_shift\", 0.97, 0.32, 0.91);\n  addAvoidPoint(debug.trim_momentary_return, \"c_5_trim_momentary_return\", 0.976, 0.078, 0.878);\n  addAvoidPoint(debug.trim_too_sharp_shift, \"c_6_trim_too_sharp_shift\", 0.576, 0.0, 0.978);\n\n  addShiftPoint(shifter.getShiftPoints(), \"path_shifter_registered_points\", 0.99, 0.99, 0.0, 0.5);\n  addAvoidPoint(debug.new_shift_points, \"path_shifter_proposed_points\", 0.99, 0.0, 0.0, 0.5);\n}\n\n}  // namespace behavior_path_planner\n"}}, "reports": [{"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "reportHash": "2cd37270a4ee6d56f1f1f8f0fe0b1a60", "checker": {"name": "readability-inconsistent-declaration-parameter-name", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-inconsistent-declaration-parameter-name.html"}, "analyzerName": "clang-tidy", "line": 79, "column": 19, "message": "function 'behavior_path_planner::AvoidanceModule::calcAvoidanceTargetObjects' has a definition with different parameter names", "events": [{"message": "the definition seen here", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 155, "column": 34}, {"message": "differing parameters are named here: ('lanelets'), in definition: ('current_lanes')", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 79, "column": 19}, {"message": "function 'behavior_path_planner::AvoidanceModule::calcAvoidanceTargetObjects' has a definition with different parameter names", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 79, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "reportHash": "ebc043116b09c292a53d021c458dd9fa", "checker": {"name": "readability-inconsistent-declaration-parameter-name", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-inconsistent-declaration-parameter-name.html"}, "analyzerName": "clang-tidy", "line": 113, "column": 8, "message": "function 'behavior_path_planner::AvoidanceModule::trimSimilarGradShiftPoint' has a definition with different parameter names", "events": [{"message": "the definition seen here", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1052, "column": 23}, {"message": "differing parameters are named here: ('shift_points'), in definition: ('avoid_points')", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 113, "column": 8}, {"message": "function 'behavior_path_planner::AvoidanceModule::trimSimilarGradShiftPoint' has a definition with different parameter names", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 113, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "reportHash": "43255279edf266c3180adf5a4283fd6e", "checker": {"name": "readability-inconsistent-declaration-parameter-name", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-inconsistent-declaration-parameter-name.html"}, "analyzerName": "clang-tidy", "line": 115, "column": 8, "message": "function 'behavior_path_planner::AvoidanceModule::trimTooSharpShift' has a definition with different parameter names", "events": [{"message": "the definition seen here", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1395, "column": 23}, {"message": "differing parameters are named here: ('shift_points'), in definition: ('avoid_points')", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 115, "column": 8}, {"message": "function 'behavior_path_planner::AvoidanceModule::trimTooSharpShift' has a definition with different parameter names", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 115, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "reportHash": "dc4f1396fb573cbf7f4b7c3b0a8632c9", "checker": {"name": "readability-inconsistent-declaration-parameter-name", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-inconsistent-declaration-parameter-name.html"}, "analyzerName": "clang-tidy", "line": 131, "column": 36, "message": "function 'behavior_path_planner::AvoidanceModule::findNewShiftPoint' has a definition with different parameter names", "events": [{"message": "the definition seen here", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2189, "column": 51}, {"message": "differing parameters are named here: ('shift_points'), in definition: ('candidates')", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 131, "column": 36}, {"message": "function 'behavior_path_planner::AvoidanceModule::findNewShiftPoint' has a definition with different parameter names", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 131, "column": 36}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "reportHash": "4268a02275e6c4d2832529323ecb6dc1", "checker": {"name": "readability-inconsistent-declaration-parameter-name", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-inconsistent-declaration-parameter-name.html"}, "analyzerName": "clang-tidy", "line": 133, "column": 8, "message": "function 'behavior_path_planner::AvoidanceModule::addShiftPointIfApproved' has a definition with different parameter names", "events": [{"message": "the definition seen here", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2130, "column": 23}, {"message": "differing parameters are named here: ('point'), in definition: ('shift_points')", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 133, "column": 8}, {"message": "function 'behavior_path_planner::AvoidanceModule::addShiftPointIfApproved' has a definition with different parameter names", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/include/behavior_path_planner/scene_module/avoidance/avoidance_module.hpp", "line": 133, "column": 8}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "84af23b1c058d9a1a9ebcea5280fb73f", "checker": {"name": "cppcoreguidelines-macro-usage", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines-macro-usage.html"}, "analyzerName": "clang-tidy", "line": 39, "column": 9, "message": "function-like macro 'printShiftPoints' used; consider a 'constexpr' template function", "events": [{"message": "function-like macro 'printShiftPoints' used; consider a 'constexpr' template function", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 39, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "38560d8a72e39c789029b1ce17640849", "checker": {"name": "misc-unused-using-decls", "url": "https://clang.llvm.org/extra/clang-tidy/checks/misc-unused-using-decls.html"}, "analyzerName": "clang-tidy", "line": 46, "column": 29, "message": "using decl 'createPoint' is unused", "events": [{"message": "remove the using", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 46, "column": 29}, {"message": "using decl 'createPoint' is unused", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 46, "column": 29}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "c4f1a38573403a4044233099f01accc9", "checker": {"name": "-warnings-as-errors", "url": null}, "analyzerName": "clang-tidy", "line": 46, "column": 29, "message": "using decl 'createPoint' is unused", "events": [{"message": "remove the using", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 46, "column": 29}, {"message": "using decl 'createPoint' is unused", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 46, "column": 29}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "46a30e52e8d1b75b5aef6ab8d9c08fe8", "checker": {"name": "readability-simplify-boolean-expr", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-simplify-boolean-expr.html"}, "analyzerName": "clang-tidy", "line": 70, "column": 33, "message": "redundant boolean literal in ternary expression result", "events": [{"message": "has_avoidance_target (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 70, "column": 10}, {"message": "redundant boolean literal in ternary expression result", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 70, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "MEDIUM"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "21f8dc8281fe6164068be5054d6ddf9e", "checker": {"name": "readability-static-accessed-through-instance", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-static-accessed-through-instance.html"}, "analyzerName": "clang-tidy", "line": 500, "column": 34, "message": "static member accessed through instance", "events": [{"message": "behavior_path_planner::PathShifter:: (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 500, "column": 34}, {"message": "static member accessed through instance", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 500, "column": 34}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "59b537f3e2d61a538312511e86cd7429", "checker": {"name": "readability-convert-member-functions-to-static", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-convert-member-functions-to-static.html"}, "analyzerName": "clang-tidy", "line": 636, "column": 34, "message": "method 'combineRawShiftPointsWithUniqueCheck' can be made static", "events": [{"message": "method 'combineRawShiftPointsWithUniqueCheck' can be made static", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 636, "column": 34}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "8446b7ca5795b1b1fb3f161fd8761d09", "checker": {"name": "readability-convert-member-functions-to-static", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-convert-member-functions-to-static.html"}, "analyzerName": "clang-tidy", "line": 884, "column": 38, "message": "method 'calcParentIds' can be made static", "events": [{"message": "method 'calcParentIds' can be made static", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 884, "column": 38}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "48b8d582ccca07b38ae350347ca9ad38", "checker": {"name": "performance-unnecessary-copy-initialization", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance-unnecessary-copy-initialization.html"}, "analyzerName": "clang-tidy", "line": 1335, "column": 12, "message": "local copy 'sp_combined' of the variable 'sp_now' is never modified; consider avoiding the copy", "events": [{"message": "const  & (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1335, "column": 7}, {"message": "local copy 'sp_combined' of the variable 'sp_now' is never modified; consider avoiding the copy", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1335, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "38da8e90f91d7f56b8e201e3d4b02fb5", "checker": {"name": "cppcoreguidelines-slicing", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines-slicing.html"}, "analyzerName": "clang-tidy", "line": 1483, "column": 15, "message": "slicing object from type 'AvoidPoint' to 'ShiftPoint' discards 1320 bytes of state", "events": [{"message": "slicing object from type 'AvoidPoint' to 'ShiftPoint' discards 1320 bytes of state", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1483, "column": 15}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "52333103e44231610dd0b4d051bbfc2f", "checker": {"name": "cppcoreguidelines-slicing", "url": "https://clang.llvm.org/extra/clang-tidy/checks/cppcoreguidelines-slicing.html"}, "analyzerName": "clang-tidy", "line": 1491, "column": 15, "message": "slicing object from type 'AvoidPoint' to 'ShiftPoint' discards 1320 bytes of state", "events": [{"message": "slicing object from type 'AvoidPoint' to 'ShiftPoint' discards 1320 bytes of state", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1491, "column": 15}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "b8c053d1f64eb8c778d5b63fa9d18b37", "checker": {"name": "readability-else-after-return", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-else-after-return.html"}, "analyzerName": "clang-tidy", "line": 1690, "column": 9, "message": "do not use 'else' after 'continue'", "events": [{"message": "do not use 'else' after 'continue'", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 1690, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "ee4574a1f3344873f63ddf5c49cdb0b4", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance-no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 2030, "column": 10, "message": "constness of 'intersection_shift_point' prevents automatic move", "events": [{"message": "constness of 'intersection_shift_point' prevents automatic move", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2030, "column": 10}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "7be9d0b9419708b378b05b2142732725", "checker": {"name": "performance-no-automatic-move", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance-no-automatic-move.html"}, "analyzerName": "clang-tidy", "line": 2285, "column": 12, "message": "constness of 'ego_pose' prevents automatic move", "events": [{"message": "constness of 'ego_pose' prevents automatic move", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2285, "column": 12}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "409af26d9af1fe2721eda0dc9fdacabc", "checker": {"name": "readability-static-accessed-through-instance", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-static-accessed-through-instance.html"}, "analyzerName": "clang-tidy", "line": 2303, "column": 33, "message": "static member accessed through instance", "events": [{"message": "behavior_path_planner::PathShifter:: (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2303, "column": 33}, {"message": "static member accessed through instance", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2303, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "409af26d9af1fe2721eda0dc9fdacabc", "checker": {"name": "readability-static-accessed-through-instance", "url": "https://clang.llvm.org/extra/clang-tidy/checks/readability-static-accessed-through-instance.html"}, "analyzerName": "clang-tidy", "line": 2312, "column": 33, "message": "static member accessed through instance", "events": [{"message": "behavior_path_planner::PathShifter:: (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2312, "column": 33}, {"message": "static member accessed through instance", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2312, "column": 33}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "STYLE"}, {"fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "reportHash": "5479f1a8a56082bc86664709c8bac96e", "checker": {"name": "performance-for-range-copy", "url": "https://clang.llvm.org/extra/clang-tidy/checks/performance-for-range-copy.html"}, "analyzerName": "clang-tidy", "line": 2452, "column": 19, "message": "the loop variable's type is not a reference type; this creates a copy in each iteration; consider making this a reference", "events": [{"message": "& (fixit)", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2452, "column": 18}, {"message": "the loop variable's type is not a reference type; this creates a copy in each iteration; consider making this a reference", "fileId": "/__w/autoware-universe-metrics-dashboard/autoware-universe-metrics-dashboard/planning/behavior_path_planner/src/scene_module/avoidance/avoidance_module.cpp", "line": 2452, "column": 19}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
